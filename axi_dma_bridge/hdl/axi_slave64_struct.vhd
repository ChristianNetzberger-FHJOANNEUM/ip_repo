-- VHDL Entity axi_dma_bridge.axi_slave64.symbol
--
-- Created:
--          by - net.Personal AEE (KPERSM7467)
--          at - 11:32:01 09/29/15
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
library work;
use work.busdef.ALL;

entity axi_slave64 is
   generic( 
      -- Width of Address Bus
      C_M00_AXI_ADDR_WIDTH   : integer := 32;
      -- Width of User Read Address Bus
      C_M00_AXI_ARUSER_WIDTH : integer := 1;
      -- Width of User Write Address Bus
      C_M00_AXI_AWUSER_WIDTH : integer := 1;
      -- Burst Length. Supports 1, 2, 4, 8, 16, 32, 64, 128, 256 burst lengths
      C_M00_AXI_BURST_LEN    : integer := 16;
      -- Width of User Response Bus
      C_M00_AXI_BUSER_WIDTH  : integer := 1;
      -- Width of Data Bus
      C_M00_AXI_DATA_WIDTH   : integer := 64;
      -- Thread ID Width
      C_M00_AXI_ID_WIDTH     : integer := 12;
      -- Width of User Read Data Bus
      C_M00_AXI_RUSER_WIDTH  : integer := 1;
      -- Width of User Write Data Bus
      C_M00_AXI_WUSER_WIDTH  : integer := 1;
      C_S00_AXI_ADDR_WIDTH   : integer := 18;
      C_S00_AXI_ARUSER_WIDTH : integer := 1;
      C_S00_AXI_AWUSER_WIDTH : integer := 1;
      C_S00_AXI_BUSER_WIDTH  : integer := 1;
      C_S00_AXI_DATA_WIDTH   : integer := 32;
      -- Users to add parameters here
      
      -- User parameters ends
      -- Do not modify the parameters beyond this line
      
      
      -- Parameters of Axi Slave Bus Interface S00_AXI
      C_S00_AXI_ID_WIDTH     : integer := 12;
      C_S00_AXI_RUSER_WIDTH  : integer := 1;
      C_S00_AXI_WUSER_WIDTH  : integer := 1;
      read_file_g            : string  := "read_file.txt";
      write_file_g           : string  := "write_file.txt"
   );
   port( 
      -- Read address. This signal indicates the initial
        -- address of a read burst transaction.
      M_AXI_ARADDR    : in     std_logic_vector (C_M00_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      M_AXI_ARBURST   : in     std_logic_vector (1 downto 0);
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      M_AXI_ARCACHE   : in     std_logic_vector (3 downto 0);
      -- Master Interface Read Address.
      M_AXI_ARID      : in     std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      M_AXI_ARLEN     : in     std_logic_vector (7 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      M_AXI_ARLOCK    : in     std_logic;
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      M_AXI_ARPROT    : in     std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each read transaction
      M_AXI_ARQOS     : in     std_logic_vector (3 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      M_AXI_ARSIZE    : in     std_logic_vector (2 downto 0);
      -- Optional User-defined signal in the read address channel.
      M_AXI_ARUSER    : in     std_logic_vector (C_M00_AXI_ARUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid read address and control information
      M_AXI_ARVALID   : in     std_logic;
      -- Master Interface Write Address
      M_AXI_AWADDR    : in     std_logic_vector (C_M00_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      M_AXI_AWBURST   : in     std_logic_vector (1 downto 0);
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      M_AXI_AWCACHE   : in     std_logic_vector (3 downto 0);
      -- Master Interface Write Address ID
      M_AXI_AWID      : in     std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      M_AXI_AWLEN     : in     std_logic_vector (7 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      M_AXI_AWLOCK    : in     std_logic;
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      M_AXI_AWPROT    : in     std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each write transaction.
      M_AXI_AWQOS     : in     std_logic_vector (3 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      M_AXI_AWSIZE    : in     std_logic_vector (2 downto 0);
      -- Optional User-defined signal in the write address channel.
      M_AXI_AWUSER    : in     std_logic_vector (C_M00_AXI_AWUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid write address and control information.
      M_AXI_AWVALID   : in     std_logic;
      -- Response ready. This signal indicates that the master
        -- can accept a write response.
      M_AXI_BREADY    : in     std_logic;
      -- Read ready. This signal indicates that the master can
        -- accept the read data and response information.
      M_AXI_RREADY    : in     std_logic;
      -- Master Interface Write Data.
      M_AXI_WDATA     : in     std_logic_vector (C_M00_AXI_DATA_WIDTH-1 downto 0);
      -- Write last. This signal indicates the last transfer in a write burst.
      M_AXI_WLAST     : in     std_logic;
      -- Write strobes. This signal indicates which byte
        -- lanes hold valid data. There is one write strobe
        -- bit for each eight bits of the write data bus.
      M_AXI_WSTRB     : in     std_logic_vector (C_M00_AXI_DATA_WIDTH/8-1 downto 0);
      -- Optional User-defined signal in the write data channel.
      M_AXI_WUSER     : in     std_logic_vector (C_M00_AXI_WUSER_WIDTH-1 downto 0);
      -- Write valid. This signal indicates that valid write
        -- data and strobes are available
      M_AXI_WVALID    : in     std_logic;
      S_AXI_ARREGION  : in     std_logic_vector (3 downto 0);
      S_AXI_AWREGION  : in     std_logic_vector (3 downto 0);
      load2mem        : in     std_logic;
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      
      -- Ports of Axi Slave Bus Interface S00_AXI
      s00_axi_aclk    : in     std_logic;
      s00_axi_aresetn : in     std_logic;
      save2file       : in     std_logic;
      -- Read address ready. This signal indicates that
        -- the slave is ready to accept an address and associated control signals
      M_AXI_ARREADY   : out    std_logic;
      -- Write address ready. This signal indicates that
        -- the slave is ready to accept an address and associated control signals
      M_AXI_AWREADY   : out    std_logic;
      -- Master Interface Write Response.
      M_AXI_BID       : out    std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Write response. This signal indicates the status of the write transaction.
      M_AXI_BRESP     : out    std_logic_vector (1 downto 0);
      -- Optional User-defined signal in the write response channel
      M_AXI_BUSER     : out    std_logic_vector (C_M00_AXI_BUSER_WIDTH-1 downto 0);
      -- Write response valid. This signal indicates that the
        -- channel is signaling a valid write response.
      M_AXI_BVALID    : out    std_logic;
      -- Master Read Data
      M_AXI_RDATA     : out    std_logic_vector (C_M00_AXI_DATA_WIDTH-1 downto 0);
      -- Read ID tag. This signal is the identification tag
        -- for the read data group of signals generated by the slave.
      M_AXI_RID       : out    std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Read last. This signal indicates the last transfer in a read burst
      M_AXI_RLAST     : out    std_logic;
      -- Read response. This signal indicates the status of the read transfer
      M_AXI_RRESP     : out    std_logic_vector (1 downto 0);
      -- Optional User-defined signal in the read address channel.
      M_AXI_RUSER     : out    std_logic_vector (C_M00_AXI_RUSER_WIDTH-1 downto 0);
      -- Read valid. This signal indicates that the channel
        -- is signaling the required read data.
      M_AXI_RVALID    : out    std_logic;
      -- Write ready. This signal indicates that the slave
        -- can accept the write data.
      M_AXI_WREADY    : out    std_logic
   );

-- Declarations

end axi_slave64 ;

--
-- VHDL Architecture axi_dma_bridge.axi_slave64.struct
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 14:30:04 30.07.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
library work;
use work.busdef.ALL;

library axi_dma_bridge;

architecture struct of axi_slave64 is

   -- Architecture declarations

   -- Internal signal declarations
   signal clk         : std_logic;
   signal header      : std_logic_vector(2 downto 0);
   signal reg00       : std_logic_vector(63 downto 0);
   signal reg01       : std_logic_vector(63 downto 0);
   signal reg02       : std_logic_vector(63 downto 0);
   signal reg03       : std_logic_vector(63 downto 0);
   signal reg04       : std_logic_vector(63 downto 0);
   signal reg08       : std_logic_vector(63 downto 0);
   signal reg_din     : std_logic_vector( 16*64-1 downto 0 );    -- parallel input for readback
   signal reg_dout    : std_logic_vector( 16*64-1 downto 0 );    -- parallel output of all registers
   signal reset       : std_logic;
   signal s64bus_i_b  : s64bus_i_t;
   signal sbus_i      : s64bus_i_t;
   signal sbus_i_mux  : s64bus_i_t;
   signal sbus_o_0    : s64bus_o_t;
   signal sbus_o_a    : s64bus_o_t;
   signal sbus_o_mux  : s64bus_o_t;
   signal sbus_o_null : s64bus_o_t;


   -- Component Declarations
   component MS00_AXI64
   generic (
      -- Users to add parameters here
      
      -- User parameters ends
      -- Do not modify the parameters beyond this line
      
      -- Width of ID for for write address, write data, read address and read data
      C_S_AXI_ID_WIDTH     : integer := 1;
      -- Width of S_AXI data bus
      C_S_AXI_DATA_WIDTH   : integer := 32;
      -- Width of S_AXI address bus
      C_S_AXI_ADDR_WIDTH   : integer := 10;
      -- Width of optional user defined signal in write address channel
      C_S_AXI_AWUSER_WIDTH : integer := 1;
      -- Width of optional user defined signal in read address channel
      C_S_AXI_ARUSER_WIDTH : integer := 1;
      -- Width of optional user defined signal in write data channel
      C_S_AXI_WUSER_WIDTH  : integer := 1;
      -- Width of optional user defined signal in read data channel
      C_S_AXI_RUSER_WIDTH  : integer := 1;
      -- Width of optional user defined signal in write response channel
      C_S_AXI_BUSER_WIDTH  : integer := 1
   );
   port (
      -- Users to add ports here
      led            : out    std_logic ;
      clk_o          : out    std_logic ;
      reset_o        : out    std_logic ;
      sbus_i         : out    s64bus_i_t ;
      sbus_o         : in     s64bus_o_t ;
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      -- Global Clock Signal
      S_AXI_ACLK     : in     std_logic ;
      -- Global Reset Signal. This Signal is Active LOW
      S_AXI_ARESETN  : in     std_logic ;
      -- Write Address ID
      S_AXI_AWID     : in     std_logic_vector (C_S_AXI_ID_WIDTH-1 downto 0);
      -- Write address
      S_AXI_AWADDR   : in     std_logic_vector (C_S_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      S_AXI_AWLEN    : in     std_logic_vector (7 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      S_AXI_AWSIZE   : in     std_logic_vector (2 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      S_AXI_AWBURST  : in     std_logic_vector (1 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      S_AXI_AWLOCK   : in     std_logic ;
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      S_AXI_AWCACHE  : in     std_logic_vector (3 downto 0);
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      S_AXI_AWPROT   : in     std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each
        -- write transaction.
      S_AXI_AWQOS    : in     std_logic_vector (3 downto 0);
      -- Region identifier. Permits a single physical interface
        -- on a slave to be used for multiple logical interfaces.
      S_AXI_AWREGION : in     std_logic_vector (3 downto 0);
      -- Optional User-defined signal in the write address channel.
      S_AXI_AWUSER   : in     std_logic_vector (C_S_AXI_AWUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid write address and
        -- control information.
      S_AXI_AWVALID  : in     std_logic ;
      -- Write address ready. This signal indicates that
        -- the slave is ready to accept an address and associated
        -- control signals.
      S_AXI_AWREADY  : out    std_logic ;
      -- Write Data
      S_AXI_WDATA    : in     std_logic_vector (C_S_AXI_DATA_WIDTH-1 downto 0);
      -- Write strobes. This signal indicates which byte
        -- lanes hold valid data. There is one write strobe
        -- bit for each eight bits of the write data bus.
      S_AXI_WSTRB    : in     std_logic_vector ((C_S_AXI_DATA_WIDTH/8)-1 downto 0);
      -- Write last. This signal indicates the last transfer
        -- in a write burst.
      S_AXI_WLAST    : in     std_logic ;
      -- Optional User-defined signal in the write data channel.
      S_AXI_WUSER    : in     std_logic_vector (C_S_AXI_WUSER_WIDTH-1 downto 0);
      -- Write valid. This signal indicates that valid write
        -- data and strobes are available.
      S_AXI_WVALID   : in     std_logic ;
      -- Write ready. This signal indicates that the slave
        -- can accept the write data.
      S_AXI_WREADY   : out    std_logic ;
      -- Response ID tag. This signal is the ID tag of the
        -- write response.
      S_AXI_BID      : out    std_logic_vector (C_S_AXI_ID_WIDTH-1 downto 0);
      -- Write response. This signal indicates the status
        -- of the write transaction.
      S_AXI_BRESP    : out    std_logic_vector (1 downto 0);
      -- Optional User-defined signal in the write response channel.
      S_AXI_BUSER    : out    std_logic_vector (C_S_AXI_BUSER_WIDTH-1 downto 0);
      -- Write response valid. This signal indicates that the
        -- channel is signaling a valid write response.
      S_AXI_BVALID   : out    std_logic ;
      -- Response ready. This signal indicates that the master
        -- can accept a write response.
      S_AXI_BREADY   : in     std_logic ;
      -- Read address ID. This signal is the identification
        -- tag for the read address group of signals.
      S_AXI_ARID     : in     std_logic_vector (C_S_AXI_ID_WIDTH-1 downto 0);
      -- Read address. This signal indicates the initial
        -- address of a read burst transaction.
      S_AXI_ARADDR   : in     std_logic_vector (C_S_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      S_AXI_ARLEN    : in     std_logic_vector (7 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      S_AXI_ARSIZE   : in     std_logic_vector (2 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      S_AXI_ARBURST  : in     std_logic_vector (1 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      S_AXI_ARLOCK   : in     std_logic ;
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      S_AXI_ARCACHE  : in     std_logic_vector (3 downto 0);
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      S_AXI_ARPROT   : in     std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each
        -- read transaction.
      S_AXI_ARQOS    : in     std_logic_vector (3 downto 0);
      -- Region identifier. Permits a single physical interface
        -- on a slave to be used for multiple logical interfaces.
      S_AXI_ARREGION : in     std_logic_vector (3 downto 0);
      -- Optional User-defined signal in the read address channel.
      S_AXI_ARUSER   : in     std_logic_vector (C_S_AXI_ARUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid read address and
        -- control information.
      S_AXI_ARVALID  : in     std_logic ;
      -- Read address ready. This signal indicates that
        -- the slave is ready to accept an address and associated
        -- control signals.
      S_AXI_ARREADY  : out    std_logic ;
      -- Read ID tag. This signal is the identification tag
        -- for the read data group of signals generated by the slave.
      S_AXI_RID      : out    std_logic_vector (C_S_AXI_ID_WIDTH-1 downto 0);
      -- Read Data
      S_AXI_RDATA    : out    std_logic_vector (C_S_AXI_DATA_WIDTH-1 downto 0);
      -- Read response. This signal indicates the status of
        -- the read transfer.
      S_AXI_RRESP    : out    std_logic_vector (1 downto 0);
      -- Read last. This signal indicates the last transfer
        -- in a read burst.
      S_AXI_RLAST    : out    std_logic ;
      -- Optional User-defined signal in the read address channel.
      S_AXI_RUSER    : out    std_logic_vector (C_S_AXI_RUSER_WIDTH-1 downto 0);
      -- Read valid. This signal indicates that the channel
        -- is signaling the required read data.
      S_AXI_RVALID   : out    std_logic ;
      -- Read ready. This signal indicates that the master can
        -- accept the read data and response information.
      S_AXI_RREADY   : in     std_logic 
   );
   end component;
   component dpram_64_fileio
   generic (
      simulation_g    : boolean := false;
      hex_format_g    : boolean := true;
      save_filename_g : string  := "dpram32_dump.txt";
      load_filename_g : string  := "dpram32_dump.txt";
      addr_base_a_g   : std_logic_vector;
      addr_base_b_g   : std_logic_vector;
      addr_range_g    : std_logic_vector;
      addr_width_g    : integer := 8;                --width of address
      data_width_g    : integer := 32                --width of data
   );
   port (
      clka      : in     std_logic ;
      save2file : in     std_logic ;
      load2mem  : in     std_logic ;
      sbus_i_a  : in     s64bus_i_t ;
      sbus_i_b  : in     s64bus_i_t ;
      sbus_o_a  : out    s64bus_o_t ;
      sbus_o_b  : out    s64bus_o_t 
   );
   end component;
   component register64_array
   generic (
      addr_width_g : integer := 8;      --width of address
      data_width_g : integer := 8;      --width of data
      addr_base_g  : std_logic_vector;
      addr_range_g : std_logic_vector;
      nregs_g      : integer := 16      --number of registers
   );
   port (
      sbus_o   : out    s64bus_o_t ;
      sbus_i   : in     s64bus_i_t ;
      reg_din  : in     std_logic_vector ( nregs_g*data_width_g-1 downto 0 ); -- parallel input for readback
      reg_dout : out    std_logic_vector ( nregs_g*data_width_g-1 downto 0 ); -- parallel output of all registers
      we       : out    std_logic_vector ( nregs_g-1 downto 0);               -- active high write strobes
      reset    : in     std_logic ;                                           -- synchronous, active high reset
      clk      : in     std_logic                                             -- register clock
   );
   end component;
   component s64bus_mux
   port (
      sbus_i_in   : in     s64bus_i_t ;
      sbus_i_out  : out    s64bus_i_t ;
      sbus_o_mux  : out    s64bus_o_t ;
      sbus_o_0    : in     s64bus_o_t ;
      sbus_o_1    : in     s64bus_o_t ;
      sbus_o_2    : in     s64bus_o_t ;
      sbus_o_3    : in     s64bus_o_t ;
      sbus_o_4    : in     s64bus_o_t ;
      sbus_o_5    : in     s64bus_o_t ;
      sbus_o_null : out    s64bus_o_t 
   );
   end component;

   -- Optional embedded configurations
   -- pragma synthesis_off
   for all : MS00_AXI64 use entity axi_dma_bridge.MS00_AXI64;
   for all : dpram_64_fileio use entity axi_dma_bridge.dpram_64_fileio;
   for all : register64_array use entity axi_dma_bridge.register64_array;
   for all : s64bus_mux use entity axi_dma_bridge.s64bus_mux;
   -- pragma synthesis_on


begin
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 8 eb7
   reg00 <= reg_dout(0*64+63 downto 0*64);
   reg01 <= reg_dout(1*64+63 downto 1*64);
   reg02 <= reg_dout(2*64+63 downto 2*64);   
   reg03 <= reg_dout(3*64+63 downto 3*64);   
   reg04 <= reg_dout(4*64+63 downto 4*64);  
   reg08 <= reg_dout(8*64+63 downto 8*64);   
    
   
   process(clk)
   begin
      if clk='1' and clk'event then
         reg_din <= reg_dout;
      end if;
   end process;                              


   -- Instance port mappings.
   U_8 : MS00_AXI64
      generic map (
         -- Users to add parameters here
         
         -- User parameters ends
         -- Do not modify the parameters beyond this line
         
         -- Width of ID for for write address, write data, read address and read data
         C_S_AXI_ID_WIDTH     => C_S00_AXI_ID_WIDTH,
         -- Width of S_AXI data bus
         C_S_AXI_DATA_WIDTH   => C_M00_AXI_DATA_WIDTH,
         -- Width of S_AXI address bus
         C_S_AXI_ADDR_WIDTH   => C_S00_AXI_ADDR_WIDTH,
         -- Width of optional user defined signal in write address channel
         C_S_AXI_AWUSER_WIDTH => C_S00_AXI_AWUSER_WIDTH,
         -- Width of optional user defined signal in read address channel
         C_S_AXI_ARUSER_WIDTH => C_S00_AXI_ARUSER_WIDTH,
         -- Width of optional user defined signal in write data channel
         C_S_AXI_WUSER_WIDTH  => C_S00_AXI_WUSER_WIDTH,
         -- Width of optional user defined signal in read data channel
         C_S_AXI_RUSER_WIDTH  => C_S00_AXI_RUSER_WIDTH,
         -- Width of optional user defined signal in write response channel
         C_S_AXI_BUSER_WIDTH  => C_S00_AXI_BUSER_WIDTH
      )
      port map (
         led            => open,
         clk_o          => clk,
         reset_o        => reset,
         sbus_i         => sbus_i_mux,
         sbus_o         => sbus_o_mux,
         S_AXI_ACLK     => s00_axi_aclk,
         S_AXI_ARESETN  => s00_axi_aresetn,
         S_AXI_AWID     => M_AXI_AWID,
         S_AXI_AWADDR   => M_AXI_AWADDR(C_S00_AXI_ADDR_WIDTH-1 downto 0),
         S_AXI_AWLEN    => M_AXI_AWLEN,
         S_AXI_AWSIZE   => M_AXI_AWSIZE,
         S_AXI_AWBURST  => M_AXI_AWBURST,
         S_AXI_AWLOCK   => M_AXI_AWLOCK,
         S_AXI_AWCACHE  => M_AXI_AWCACHE,
         S_AXI_AWPROT   => M_AXI_AWPROT,
         S_AXI_AWQOS    => M_AXI_AWQOS,
         S_AXI_AWREGION => S_AXI_AWREGION,
         S_AXI_AWUSER   => M_AXI_AWUSER,
         S_AXI_AWVALID  => M_AXI_AWVALID,
         S_AXI_AWREADY  => M_AXI_AWREADY,
         S_AXI_WDATA    => M_AXI_WDATA,
         S_AXI_WSTRB    => M_AXI_WSTRB,
         S_AXI_WLAST    => M_AXI_WLAST,
         S_AXI_WUSER    => M_AXI_WUSER,
         S_AXI_WVALID   => M_AXI_WVALID,
         S_AXI_WREADY   => M_AXI_WREADY,
         S_AXI_BID      => M_AXI_BID,
         S_AXI_BRESP    => M_AXI_BRESP,
         S_AXI_BUSER    => M_AXI_BUSER,
         S_AXI_BVALID   => M_AXI_BVALID,
         S_AXI_BREADY   => M_AXI_BREADY,
         S_AXI_ARID     => M_AXI_ARID,
         S_AXI_ARADDR   => M_AXI_ARADDR(C_S00_AXI_ADDR_WIDTH-1 downto 0),
         S_AXI_ARLEN    => M_AXI_ARLEN,
         S_AXI_ARSIZE   => M_AXI_ARSIZE,
         S_AXI_ARBURST  => M_AXI_ARBURST,
         S_AXI_ARLOCK   => M_AXI_ARLOCK,
         S_AXI_ARCACHE  => M_AXI_ARCACHE,
         S_AXI_ARPROT   => M_AXI_ARPROT,
         S_AXI_ARQOS    => M_AXI_ARQOS,
         S_AXI_ARREGION => S_AXI_ARREGION,
         S_AXI_ARUSER   => M_AXI_ARUSER,
         S_AXI_ARVALID  => M_AXI_ARVALID,
         S_AXI_ARREADY  => M_AXI_ARREADY,
         S_AXI_RID      => M_AXI_RID,
         S_AXI_RDATA    => M_AXI_RDATA,
         S_AXI_RRESP    => M_AXI_RRESP,
         S_AXI_RLAST    => M_AXI_RLAST,
         S_AXI_RUSER    => M_AXI_RUSER,
         S_AXI_RVALID   => M_AXI_RVALID,
         S_AXI_RREADY   => M_AXI_RREADY
      );
   U_1 : dpram_64_fileio
      generic map (
         simulation_g    => true,
         hex_format_g    => true,
         save_filename_g => "dpram64_dump.txt",
         load_filename_g => "dpram64_read.txt",
         addr_base_a_g   => X"00000000",
         addr_base_b_g   => X"00000000",
         addr_range_g    => X"00000100",
         addr_width_g    => 8,                --width of address
         data_width_g    => 64                --width of data
      )
      port map (
         clka      => clk,
         save2file => save2file,
         load2mem  => load2mem,
         sbus_i_a  => sbus_i,
         sbus_i_b  => s64bus_i_b,
         sbus_o_a  => sbus_o_a,
         sbus_o_b  => open
      );
   U_10 : register64_array
      generic map (
         addr_width_g => 16,         --width of address
         data_width_g => 64,         --width of data
         addr_base_g  => X"00002000",
         addr_range_g => X"00000010",
         nregs_g      => 16          --number of registers
      )
      port map (
         sbus_o   => sbus_o_0,
         sbus_i   => sbus_i,
         reg_din  => reg_din,
         reg_dout => reg_dout,
         we       => open,
         reset    => reset,
         clk      => clk
      );
   U_9 : s64bus_mux
      port map (
         sbus_i_in   => sbus_i_mux,
         sbus_i_out  => sbus_i,
         sbus_o_mux  => sbus_o_mux,
         sbus_o_0    => sbus_o_0,
         sbus_o_1    => sbus_o_a,
         sbus_o_2    => sbus_o_null,
         sbus_o_3    => sbus_o_null,
         sbus_o_4    => sbus_o_null,
         sbus_o_5    => sbus_o_null,
         sbus_o_null => sbus_o_null
      );

end struct;
