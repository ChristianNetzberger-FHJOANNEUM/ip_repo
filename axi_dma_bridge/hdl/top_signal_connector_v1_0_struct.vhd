-- VHDL Entity axi_dma_bridge.top_signal_connector_v1_0.symbol
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 09:06:10 07.11.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
library work;
use work.busdef.all;

entity top_signal_connector_v1_0 is
   generic( 
      C_M00_AXI_ADDR_WIDTH             : integer          := 32;
      C_M00_AXI_ARUSER_WIDTH           : integer          := 0;
      C_M00_AXI_AWUSER_WIDTH           : integer          := 0;
      C_M00_AXI_BURST_LEN              : integer          := 16;
      C_M00_AXI_BUSER_WIDTH            : integer          := 0;
      C_M00_AXI_DATA_WIDTH             : integer          := 64;
      C_M00_AXI_ID_WIDTH               : integer          := 1;
      C_M00_AXI_RUSER_WIDTH            : integer          := 0;
      -- Parameters of Axi Master Bus Interface M00_AXI
      C_M00_AXI_TARGET_SLAVE_BASE_ADDR : std_logic_vector := x"40000000";
      C_M00_AXI_WUSER_WIDTH            : integer          := 0;
      C_S00_AXI_ADDR_WIDTH             : integer          := 10;
      C_S00_AXI_ARUSER_WIDTH           : integer          := 0;
      C_S00_AXI_AWUSER_WIDTH           : integer          := 0;
      C_S00_AXI_BUSER_WIDTH            : integer          := 0;
      C_S00_AXI_DATA_WIDTH             : integer          := 32;
      -- Users to add parameters here
      
      -- User parameters ends
      -- Do not modify the parameters beyond this line
      
      
      -- Parameters of Axi Slave Bus Interface S00_AXI
      C_S00_AXI_ID_WIDTH               : integer          := 1;
      C_S00_AXI_RUSER_WIDTH            : integer          := 0;
      C_S00_AXI_WUSER_WIDTH            : integer          := 0;
      C_SLV_ADDR_WIDTH                 : integer          := 16;
      C_SLV_DATA_WIDTH                 : integer          := 32;
      C_SYNC_WidTH                     : integer          := 8
   );
   port( 
      -- Global Clock Signal.
      M00_AXI_ACLK        : in     std_logic;
      -- Global Reset Singal. This Signal is Active Low
      M00_AXI_ARESETN     : in     std_logic;
      -- Read address ready. This signal indicates that
        -- the slave is ready to accept an address and associated control signals
      M00_AXI_ARREADY     : in     std_logic;
      -- Write address ready. This signal indicates that
        -- the slave is ready to accept an address and associated control signals
      M00_AXI_AWREADY     : in     std_logic;
      -- Master Interface Write Response.
      M00_AXI_BID         : in     std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Write response. This signal indicates the status of the write transaction.
      M00_AXI_BRESP       : in     std_logic_vector (1 downto 0);
      -- Optional User-defined signal in the write response channel
      M00_AXI_BUSER       : in     std_logic_vector (C_M00_AXI_BUSER_WIDTH-1 downto 0);
      -- Write response valid. This signal indicates that the
        -- channel is signaling a valid write response.
      M00_AXI_BVALID      : in     std_logic;
      -- Master Read Data
      M00_AXI_RDATA       : in     std_logic_vector (C_M00_AXI_DATA_WIDTH-1 downto 0);
      -- Read ID tag. This signal is the identification tag
        -- for the read data group of signals generated by the slave.
      M00_AXI_RID         : in     std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Read last. This signal indicates the last transfer in a read burst
      M00_AXI_RLAST       : in     std_logic;
      -- Read response. This signal indicates the status of the read transfer
      M00_AXI_RRESP       : in     std_logic_vector (1 downto 0);
      -- Optional User-defined signal in the read address channel.
      M00_AXI_RUSER       : in     std_logic_vector (C_M00_AXI_RUSER_WIDTH-1 downto 0);
      -- Read valid. This signal indicates that the channel
        -- is signaling the required read data.
      M00_AXI_RVALID      : in     std_logic;
      -- Write ready. This signal indicates that the slave
        -- can accept the write data.
      M00_AXI_WREADY      : in     std_logic;
      dma_rd              : in     std_logic;
      dma_rd_addr         : in     std_logic_vector (31  downto 0);
      dma_rd_mode         : in     std_logic_vector (3  downto 0);
      dma_rd_request_size : in     std_logic_vector (31  downto 0);
      dma_wdata           : in     std_logic_vector (C_M00_AXI_DATA_WIDTH-1  downto 0);
      dma_wr              : in     std_logic;
      dma_wr_addr         : in     std_logic_vector (31  downto 0);
      dma_wr_mode         : in     std_logic_vector (3  downto 0);
      dma_wr_request_size : in     std_logic_vector (31  downto 0);
      -- Users to add ports here
      
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      
      -- Ports of Axi Slave Bus Interface S00_AXI
      s00_axi_aclk        : in     std_logic;
      s00_axi_araddr      : in     std_logic_vector (C_S00_AXI_ADDR_WIDTH-1 downto 0);
      s00_axi_arburst     : in     std_logic_vector (1 downto 0);
      s00_axi_arcache     : in     std_logic_vector (3 downto 0);
      s00_axi_aresetn     : in     std_logic;
      s00_axi_arid        : in     std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_arlen       : in     std_logic_vector (7 downto 0);
      s00_axi_arlock      : in     std_logic;
      s00_axi_arprot      : in     std_logic_vector (2 downto 0);
      s00_axi_arqos       : in     std_logic_vector (3 downto 0);
      s00_axi_arregion    : in     std_logic_vector (3 downto 0);
      s00_axi_arsize      : in     std_logic_vector (2 downto 0);
      s00_axi_aruser      : in     std_logic_vector (C_S00_AXI_ARUSER_WIDTH-1 downto 0);
      s00_axi_arvalid     : in     std_logic;
      s00_axi_awaddr      : in     std_logic_vector (C_S00_AXI_ADDR_WIDTH-1 downto 0);
      s00_axi_awburst     : in     std_logic_vector (1 downto 0);
      s00_axi_awcache     : in     std_logic_vector (3 downto 0);
      s00_axi_awid        : in     std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_awlen       : in     std_logic_vector (7 downto 0);
      s00_axi_awlock      : in     std_logic;
      s00_axi_awprot      : in     std_logic_vector (2 downto 0);
      s00_axi_awqos       : in     std_logic_vector (3 downto 0);
      s00_axi_awregion    : in     std_logic_vector (3 downto 0);
      s00_axi_awsize      : in     std_logic_vector (2 downto 0);
      s00_axi_awuser      : in     std_logic_vector (C_S00_AXI_AWUSER_WIDTH-1 downto 0);
      s00_axi_awvalid     : in     std_logic;
      s00_axi_bready      : in     std_logic;
      s00_axi_rready      : in     std_logic;
      s00_axi_wdata       : in     std_logic_vector (C_S00_AXI_DATA_WIDTH-1 downto 0);
      s00_axi_wlast       : in     std_logic;
      s00_axi_wstrb       : in     std_logic_vector ((C_S00_AXI_DATA_WIDTH/8)-1 downto 0);
      s00_axi_wuser       : in     std_logic_vector (C_S00_AXI_WUSER_WIDTH-1 downto 0);
      s00_axi_wvalid      : in     std_logic;
      sbus_ack            : in     std_logic;
      sbus_rdata          : in     std_logic_vector (31 downto 0);
      sync_i              : in     std_logic_vector (C_SYNC_WIDTH-1 downto 0);
      xfer_sync_ext       : in     std_logic;
      -- Read address. This signal indicates the initial
        -- address of a read burst transaction.
      M00_AXI_ARADDR      : out    std_logic_vector (C_M00_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      M00_AXI_ARBURST     : out    std_logic_vector (1 downto 0);
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      M00_AXI_ARCACHE     : out    std_logic_vector (3 downto 0);
      -- Master Interface Read Address.
      M00_AXI_ARID        : out    std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      M00_AXI_ARLEN       : out    std_logic_vector (7 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      M00_AXI_ARLOCK      : out    std_logic;
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      M00_AXI_ARPROT      : out    std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each read transaction
      M00_AXI_ARQOS       : out    std_logic_vector (3 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      M00_AXI_ARSIZE      : out    std_logic_vector (2 downto 0);
      -- Optional User-defined signal in the read address channel.
      M00_AXI_ARUSER      : out    std_logic_vector (C_M00_AXI_ARUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid read address and control information
      M00_AXI_ARVALID     : out    std_logic;
      -- Master Interface Write Address
      M00_AXI_AWADDR      : out    std_logic_vector (C_M00_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      M00_AXI_AWBURST     : out    std_logic_vector (1 downto 0);
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      M00_AXI_AWCACHE     : out    std_logic_vector (3 downto 0);
      -- Master Interface Write Address ID
      M00_AXI_AWID        : out    std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      M00_AXI_AWLEN       : out    std_logic_vector (7 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      M00_AXI_AWLOCK      : out    std_logic;
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      M00_AXI_AWPROT      : out    std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each write transaction.
      M00_AXI_AWQOS       : out    std_logic_vector (3 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      M00_AXI_AWSIZE      : out    std_logic_vector (2 downto 0);
      -- Optional User-defined signal in the write address channel.
      M00_AXI_AWUSER      : out    std_logic_vector (C_M00_AXI_AWUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid write address and control information.
      M00_AXI_AWVALID     : out    std_logic;
      -- Response ready. This signal indicates that the master
        -- can accept a write response.
      M00_AXI_BREADY      : out    std_logic;
      -- Read ready. This signal indicates that the master can
        -- accept the read data and response information.
      M00_AXI_RREADY      : out    std_logic;
      -- Master Interface Write Data.
      M00_AXI_WDATA       : out    std_logic_vector (C_M00_AXI_DATA_WIDTH-1 downto 0);
      -- Write last. This signal indicates the last transfer in a write burst.
      M00_AXI_WLAST       : out    std_logic;
      -- Write strobes. This signal indicates which byte
        -- lanes hold valid data. There is one write strobe
        -- bit for each eight bits of the write data bus.
      M00_AXI_WSTRB       : out    std_logic_vector (C_M00_AXI_DATA_WIDTH/8-1 downto 0);
      -- Optional User-defined signal in the write data channel.
      M00_AXI_WUSER       : out    std_logic_vector (C_M00_AXI_WUSER_WIDTH-1 downto 0);
      -- Write valid. This signal indicates that valid write
        -- data and strobes are available
      M00_AXI_WVALID      : out    std_logic;
      dma_rd_fifosize     : out    std_logic_vector (15 downto 0);
      dma_rdata           : out    std_logic_vector (C_M00_AXI_DATA_WIDTH-1  downto 0);
      dma_wr_fifosize     : out    std_logic_vector (15 downto 0);
      irq                 : out    std_logic;
      s00_axi_arready     : out    std_logic;
      s00_axi_awready     : out    std_logic;
      s00_axi_bid         : out    std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_bresp       : out    std_logic_vector (1 downto 0);
      s00_axi_buser       : out    std_logic_vector (C_S00_AXI_BUSER_WIDTH-1 downto 0);
      s00_axi_bvalid      : out    std_logic;
      s00_axi_rdata       : out    std_logic_vector (C_S00_AXI_DATA_WIDTH-1 downto 0);
      s00_axi_rid         : out    std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_rlast       : out    std_logic;
      s00_axi_rresp       : out    std_logic_vector (1 downto 0);
      s00_axi_ruser       : out    std_logic_vector (C_S00_AXI_RUSER_WIDTH-1 downto 0);
      s00_axi_rvalid      : out    std_logic;
      s00_axi_wready      : out    std_logic;
      sbus_addr           : out    std_logic_vector (15 downto 0);
      sbus_be             : out    std_logic_vector (3 downto 0);
      sbus_rd             : out    std_logic;
      sbus_wdata          : out    std_logic_vector (31 downto 0);
      sbus_we             : out    std_logic;
      sync_o              : out    std_logic_vector (C_SYNC_WIDTH-1 downto 0);
      xfer_done           : out    std_logic
   );

-- Declarations

end top_signal_connector_v1_0 ;

--
-- VHDL Architecture axi_dma_bridge.top_signal_connector_v1_0.struct
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 12:30:32 23.11.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
library work;
use work.busdef.all;

library axi_dma_bridge;

architecture struct of top_signal_connector_v1_0 is

   -- Architecture declarations

   -- Internal signal declarations
   -- Users to add ports here
   signal clk   : std_logic;
   signal hi    : std_logic;
   signal lo    : std_logic;
   signal reset : std_logic;


-- #pragma translate_off
attribute mark_debug : string;
--attribute mark_debug of sbus_i_in: signal is "true";
--attribute mark_debug of sbus_o_mux: signal is "true";
-- #pragma translate_on

   -- Component Declarations
   component top_axi_dma_bridge
   generic (
      C_M00_AXI_ADDR_WIDTH             : integer          := 64;
      C_M00_AXI_ARUSER_WIDTH           : integer          := 0;
      C_M00_AXI_AWUSER_WIDTH           : integer          := 0;
      C_M00_AXI_BURST_LEN              : integer          := 16;
      C_M00_AXI_BUSER_WIDTH            : integer          := 0;
      C_M00_AXI_DATA_WIDTH             : integer          := 64;
      C_M00_AXI_ID_WIDTH               : integer          := 1;
      C_M00_AXI_RUSER_WIDTH            : integer          := 0;
      -- Parameters of Axi Master Bus Interface M00_AXI
      C_M00_AXI_TARGET_SLAVE_BASE_ADDR : std_logic_vector := x"40000000";
      C_M00_AXI_WUSER_WIDTH            : integer          := 0;
      C_S00_AXI_ADDR_WIDTH             : integer          := 18;
      C_S00_AXI_ARUSER_WIDTH           : integer          := 0;
      C_S00_AXI_AWUSER_WIDTH           : integer          := 0;
      C_S00_AXI_BUSER_WIDTH            : integer          := 0;
      C_S00_AXI_DATA_WIDTH             : integer          := 32;
      -- Users to add parameters here
      
      -- User parameters ends
      -- Do not modify the parameters beyond this line
      
      
      -- Parameters of Axi Slave Bus Interface S00_AXI
      C_S00_AXI_ID_WIDTH               : integer          := 1;
      C_S00_AXI_RUSER_WIDTH            : integer          := 0;
      C_S00_AXI_WUSER_WIDTH            : integer          := 0;
      C_SLV_ADDR_WIDTH                 : integer          := 16;
      C_SLV_DATA_WIDTH                 : integer          := 32;
      C_SLOT_NUM                       : integer          := 30;
      C_SYNC_WIDTH                     : integer          := 100;
      C_CORE_CLK_FREQ                  : integer          := 100000000;
      C_USE_TARGET_ADDR_FIFO           : boolean          := false
   );
   port (
      -- Global Clock Signal.
      M00_AXI_ACLK        : in     std_logic ;
      -- Global Reset Singal. This Signal is Active Low
      M00_AXI_ARESETN     : in     std_logic ;
      -- Read address ready. This signal indicates that
        -- the slave is ready to accept an address and associated control signals
      M00_AXI_ARREADY     : in     std_logic ;
      -- Write address ready. This signal indicates that
        -- the slave is ready to accept an address and associated control signals
      M00_AXI_AWREADY     : in     std_logic ;
      -- Master Interface Write Response.
      M00_AXI_BID         : in     std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Write response. This signal indicates the status of the write transaction.
      M00_AXI_BRESP       : in     std_logic_vector (1 downto 0);
      -- Optional User-defined signal in the write response channel
      M00_AXI_BUSER       : in     std_logic_vector (C_M00_AXI_BUSER_WIDTH-1 downto 0);
      -- Write response valid. This signal indicates that the
        -- channel is signaling a valid write response.
      M00_AXI_BVALID      : in     std_logic ;
      -- Master Read Data
      M00_AXI_RDATA       : in     std_logic_vector (C_M00_AXI_DATA_WIDTH-1 downto 0);
      -- Read ID tag. This signal is the identification tag
        -- for the read data group of signals generated by the slave.
      M00_AXI_RID         : in     std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Read last. This signal indicates the last transfer in a read burst
      M00_AXI_RLAST       : in     std_logic ;
      -- Read response. This signal indicates the status of the read transfer
      M00_AXI_RRESP       : in     std_logic_vector (1 downto 0);
      -- Optional User-defined signal in the read address channel.
      M00_AXI_RUSER       : in     std_logic_vector (C_M00_AXI_RUSER_WIDTH-1 downto 0);
      -- Read valid. This signal indicates that the channel
        -- is signaling the required read data.
      M00_AXI_RVALID      : in     std_logic ;
      -- Write ready. This signal indicates that the slave
        -- can accept the write data.
      M00_AXI_WREADY      : in     std_logic ;
      dma_rd              : in     std_logic ;
      dma_rd_addr         : in     std_logic_vector (31  downto 0);
      dma_rd_mode         : in     std_logic_vector (3  downto 0);
      dma_rd_request_size : in     std_logic_vector (31  downto 0);
      dma_wdata           : in     std_logic_vector (C_M00_AXI_DATA_WIDTH-1  downto 0);
      dma_wr              : in     std_logic ;
      dma_wr_addr         : in     std_logic_vector (31  downto 0);
      dma_wr_mode         : in     std_logic_vector (3  downto 0);
      dma_wr_request_size : in     std_logic_vector (31  downto 0);
      -- Users to add ports here
      
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      
      -- Ports of Axi Slave Bus Interface S00_AXI
      s00_axi_aclk        : in     std_logic ;
      s00_axi_araddr      : in     std_logic_vector (C_S00_AXI_ADDR_WIDTH-1 downto 0);
      s00_axi_arburst     : in     std_logic_vector (1 downto 0);
      s00_axi_arcache     : in     std_logic_vector (3 downto 0);
      s00_axi_aresetn     : in     std_logic ;
      s00_axi_arid        : in     std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_arlen       : in     std_logic_vector (7 downto 0);
      s00_axi_arlock      : in     std_logic ;
      s00_axi_arprot      : in     std_logic_vector (2 downto 0);
      s00_axi_arqos       : in     std_logic_vector (3 downto 0);
      s00_axi_arregion    : in     std_logic_vector (3 downto 0);
      s00_axi_arsize      : in     std_logic_vector (2 downto 0);
      s00_axi_aruser      : in     std_logic_vector (C_S00_AXI_ARUSER_WIDTH-1 downto 0);
      s00_axi_arvalid     : in     std_logic ;
      s00_axi_awaddr      : in     std_logic_vector (C_S00_AXI_ADDR_WIDTH-1 downto 0);
      s00_axi_awburst     : in     std_logic_vector (1 downto 0);
      s00_axi_awcache     : in     std_logic_vector (3 downto 0);
      s00_axi_awid        : in     std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_awlen       : in     std_logic_vector (7 downto 0);
      s00_axi_awlock      : in     std_logic ;
      s00_axi_awprot      : in     std_logic_vector (2 downto 0);
      s00_axi_awqos       : in     std_logic_vector (3 downto 0);
      s00_axi_awregion    : in     std_logic_vector (3 downto 0);
      s00_axi_awsize      : in     std_logic_vector (2 downto 0);
      s00_axi_awuser      : in     std_logic_vector (C_S00_AXI_AWUSER_WIDTH-1 downto 0);
      s00_axi_awvalid     : in     std_logic ;
      s00_axi_bready      : in     std_logic ;
      s00_axi_rready      : in     std_logic ;
      s00_axi_wdata       : in     std_logic_vector (C_S00_AXI_DATA_WIDTH-1 downto 0);
      s00_axi_wlast       : in     std_logic ;
      s00_axi_wstrb       : in     std_logic_vector ((C_S00_AXI_DATA_WIDTH/8)-1 downto 0);
      s00_axi_wuser       : in     std_logic_vector (C_S00_AXI_WUSER_WIDTH-1 downto 0);
      s00_axi_wvalid      : in     std_logic ;
      sbus_ack            : in     std_logic ;
      sbus_rdata          : in     std_logic_vector (31 downto 0);
      sync_i              : in     std_logic_vector (C_SYNC_WIDTH-1 downto 0);
      xfer_sync_ext       : in     std_logic ;
      -- Read address. This signal indicates the initial
        -- address of a read burst transaction.
      M00_AXI_ARADDR      : out    std_logic_vector (C_M00_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      M00_AXI_ARBURST     : out    std_logic_vector (1 downto 0);
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      M00_AXI_ARCACHE     : out    std_logic_vector (3 downto 0);
      -- Master Interface Read Address.
      M00_AXI_ARID        : out    std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      M00_AXI_ARLEN       : out    std_logic_vector (7 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      M00_AXI_ARLOCK      : out    std_logic ;
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      M00_AXI_ARPROT      : out    std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each read transaction
      M00_AXI_ARQOS       : out    std_logic_vector (3 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      M00_AXI_ARSIZE      : out    std_logic_vector (2 downto 0);
      -- Optional User-defined signal in the read address channel.
      M00_AXI_ARUSER      : out    std_logic_vector (C_M00_AXI_ARUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid read address and control information
      M00_AXI_ARVALID     : out    std_logic ;
      -- Master Interface Write Address
      M00_AXI_AWADDR      : out    std_logic_vector (C_M00_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      M00_AXI_AWBURST     : out    std_logic_vector (1 downto 0);
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      M00_AXI_AWCACHE     : out    std_logic_vector (3 downto 0);
      -- Master Interface Write Address ID
      M00_AXI_AWID        : out    std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      M00_AXI_AWLEN       : out    std_logic_vector (7 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      M00_AXI_AWLOCK      : out    std_logic ;
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      M00_AXI_AWPROT      : out    std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each write transaction.
      M00_AXI_AWQOS       : out    std_logic_vector (3 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      M00_AXI_AWSIZE      : out    std_logic_vector (2 downto 0);
      -- Optional User-defined signal in the write address channel.
      M00_AXI_AWUSER      : out    std_logic_vector (C_M00_AXI_AWUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid write address and control information.
      M00_AXI_AWVALID     : out    std_logic ;
      -- Response ready. This signal indicates that the master
        -- can accept a write response.
      M00_AXI_BREADY      : out    std_logic ;
      -- Read ready. This signal indicates that the master can
        -- accept the read data and response information.
      M00_AXI_RREADY      : out    std_logic ;
      -- Master Interface Write Data.
      M00_AXI_WDATA       : out    std_logic_vector (C_M00_AXI_DATA_WIDTH-1 downto 0);
      -- Write last. This signal indicates the last transfer in a write burst.
      M00_AXI_WLAST       : out    std_logic ;
      -- Write strobes. This signal indicates which byte
        -- lanes hold valid data. There is one write strobe
        -- bit for each eight bits of the write data bus.
      M00_AXI_WSTRB       : out    std_logic_vector (C_M00_AXI_DATA_WIDTH/8-1 downto 0);
      -- Optional User-defined signal in the write data channel.
      M00_AXI_WUSER       : out    std_logic_vector (C_M00_AXI_WUSER_WIDTH-1 downto 0);
      -- Write valid. This signal indicates that valid write
        -- data and strobes are available
      M00_AXI_WVALID      : out    std_logic ;
      -- Users to add ports here
      clk                 : out    std_logic ;
      dma_rd_fifosize     : out    std_logic_vector (15 downto 0);
      dma_rdata           : out    std_logic_vector (C_M00_AXI_DATA_WIDTH-1  downto 0);
      dma_wr_fifosize     : out    std_logic_vector (15 downto 0);
      irq                 : out    std_logic ;
      reset               : out    std_logic ;
      s00_axi_arready     : out    std_logic ;
      s00_axi_awready     : out    std_logic ;
      s00_axi_bid         : out    std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_bresp       : out    std_logic_vector (1 downto 0);
      s00_axi_buser       : out    std_logic_vector (C_S00_AXI_BUSER_WIDTH-1 downto 0);
      s00_axi_bvalid      : out    std_logic ;
      s00_axi_rdata       : out    std_logic_vector (C_S00_AXI_DATA_WIDTH-1 downto 0);
      s00_axi_rid         : out    std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_rlast       : out    std_logic ;
      s00_axi_rresp       : out    std_logic_vector (1 downto 0);
      s00_axi_ruser       : out    std_logic_vector (C_S00_AXI_RUSER_WIDTH-1 downto 0);
      s00_axi_rvalid      : out    std_logic ;
      s00_axi_wready      : out    std_logic ;
      sbus_addr           : out    std_logic_vector (15 downto 0);
      sbus_be             : out    std_logic_vector (3 downto 0);
      sbus_rd             : out    std_logic ;
      sbus_wdata          : out    std_logic_vector (31 downto 0);
      sbus_we             : out    std_logic ;
      sync_o              : out    std_logic_vector (C_SYNC_WIDTH-1 downto 0);
      xfer_done           : out    std_logic 
   );
   end component;

   -- Optional embedded configurations
   -- pragma synthesis_off
   for all : top_axi_dma_bridge use entity axi_dma_bridge.top_axi_dma_bridge;
   -- pragma synthesis_on


begin
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 9 constant_values2
   -- constant logic values
   hi <= '1';
   lo <= '0';                                     


   -- Instance port mappings.
   U_0 : top_axi_dma_bridge
      generic map (
         C_M00_AXI_ADDR_WIDTH             => 32,
         C_M00_AXI_ARUSER_WIDTH           => C_M00_AXI_ARUSER_WIDTH,
         C_M00_AXI_AWUSER_WIDTH           => C_M00_AXI_AWUSER_WIDTH,
         C_M00_AXI_BURST_LEN              => 16,
         C_M00_AXI_BUSER_WIDTH            => C_M00_AXI_BUSER_WIDTH,
         C_M00_AXI_DATA_WIDTH             => C_M00_AXI_DATA_WIDTH,
         C_M00_AXI_ID_WIDTH               => C_M00_AXI_ID_WIDTH,
         C_M00_AXI_RUSER_WIDTH            => C_M00_AXI_RUSER_WIDTH,
         -- Parameters of Axi Master Bus Interface M00_AXI
         C_M00_AXI_TARGET_SLAVE_BASE_ADDR => x"40000000",
         C_M00_AXI_WUSER_WIDTH            => C_M00_AXI_WUSER_WIDTH,
         C_S00_AXI_ADDR_WIDTH             => C_S00_AXI_ADDR_WIDTH,
         C_S00_AXI_ARUSER_WIDTH           => C_S00_AXI_ARUSER_WIDTH,
         C_S00_AXI_AWUSER_WIDTH           => C_S00_AXI_AWUSER_WIDTH,
         C_S00_AXI_BUSER_WIDTH            => C_S00_AXI_BUSER_WIDTH,
         C_S00_AXI_DATA_WIDTH             => 32,
         -- Users to add parameters here
         
         -- User parameters ends
         -- Do not modify the parameters beyond this line
         
         
         -- Parameters of Axi Slave Bus Interface S00_AXI
         C_S00_AXI_ID_WIDTH               => C_S00_AXI_ID_WIDTH,
         C_S00_AXI_RUSER_WIDTH            => C_S00_AXI_RUSER_WIDTH,
         C_S00_AXI_WUSER_WIDTH            => C_S00_AXI_WUSER_WIDTH,
         C_SLV_ADDR_WIDTH                 => 16,
         C_SLV_DATA_WIDTH                 => 32,
         C_SLOT_NUM                       => 30,
         C_SYNC_WIDTH                     => 8,
         C_CORE_CLK_FREQ                  => 100000000,
         C_USE_TARGET_ADDR_FIFO           => true
      )
      port map (
         M00_AXI_ACLK        => M00_AXI_ACLK,
         M00_AXI_ARESETN     => M00_AXI_ARESETN,
         M00_AXI_ARREADY     => M00_AXI_ARREADY,
         M00_AXI_AWREADY     => M00_AXI_AWREADY,
         M00_AXI_BID         => M00_AXI_BID,
         M00_AXI_BRESP       => M00_AXI_BRESP,
         M00_AXI_BUSER       => M00_AXI_BUSER,
         M00_AXI_BVALID      => M00_AXI_BVALID,
         M00_AXI_RDATA       => M00_AXI_RDATA,
         M00_AXI_RID         => M00_AXI_RID,
         M00_AXI_RLAST       => M00_AXI_RLAST,
         M00_AXI_RRESP       => M00_AXI_RRESP,
         M00_AXI_RUSER       => M00_AXI_RUSER,
         M00_AXI_RVALID      => M00_AXI_RVALID,
         M00_AXI_WREADY      => M00_AXI_WREADY,
         dma_rd              => dma_rd,
         dma_rd_addr         => dma_rd_addr,
         dma_rd_mode         => dma_rd_mode,
         dma_rd_request_size => dma_rd_request_size,
         dma_wdata           => dma_wdata,
         dma_wr              => dma_wr,
         dma_wr_addr         => dma_wr_addr,
         dma_wr_mode         => dma_wr_mode,
         dma_wr_request_size => dma_wr_request_size,
         s00_axi_aclk        => s00_axi_aclk,
         s00_axi_araddr      => s00_axi_araddr,
         s00_axi_arburst     => s00_axi_arburst,
         s00_axi_arcache     => s00_axi_arcache,
         s00_axi_aresetn     => s00_axi_aresetn,
         s00_axi_arid        => s00_axi_arid,
         s00_axi_arlen       => s00_axi_arlen,
         s00_axi_arlock      => s00_axi_arlock,
         s00_axi_arprot      => s00_axi_arprot,
         s00_axi_arqos       => s00_axi_arqos,
         s00_axi_arregion    => s00_axi_arregion,
         s00_axi_arsize      => s00_axi_arsize,
         s00_axi_aruser      => s00_axi_aruser,
         s00_axi_arvalid     => s00_axi_arvalid,
         s00_axi_awaddr      => s00_axi_awaddr,
         s00_axi_awburst     => s00_axi_awburst,
         s00_axi_awcache     => s00_axi_awcache,
         s00_axi_awid        => s00_axi_awid,
         s00_axi_awlen       => s00_axi_awlen,
         s00_axi_awlock      => s00_axi_awlock,
         s00_axi_awprot      => s00_axi_awprot,
         s00_axi_awqos       => s00_axi_awqos,
         s00_axi_awregion    => s00_axi_awregion,
         s00_axi_awsize      => s00_axi_awsize,
         s00_axi_awuser      => s00_axi_awuser,
         s00_axi_awvalid     => s00_axi_awvalid,
         s00_axi_bready      => s00_axi_bready,
         s00_axi_rready      => s00_axi_rready,
         s00_axi_wdata       => s00_axi_wdata,
         s00_axi_wlast       => s00_axi_wlast,
         s00_axi_wstrb       => s00_axi_wstrb,
         s00_axi_wuser       => s00_axi_wuser,
         s00_axi_wvalid      => s00_axi_wvalid,
         sbus_ack            => sbus_ack,
         sbus_rdata          => sbus_rdata,
         sync_i              => sync_i,
         xfer_sync_ext       => xfer_sync_ext,
         M00_AXI_ARADDR      => M00_AXI_ARADDR,
         M00_AXI_ARBURST     => M00_AXI_ARBURST,
         M00_AXI_ARCACHE     => M00_AXI_ARCACHE,
         M00_AXI_ARID        => M00_AXI_ARID,
         M00_AXI_ARLEN       => M00_AXI_ARLEN,
         M00_AXI_ARLOCK      => M00_AXI_ARLOCK,
         M00_AXI_ARPROT      => M00_AXI_ARPROT,
         M00_AXI_ARQOS       => M00_AXI_ARQOS,
         M00_AXI_ARSIZE      => M00_AXI_ARSIZE,
         M00_AXI_ARUSER      => M00_AXI_ARUSER,
         M00_AXI_ARVALID     => M00_AXI_ARVALID,
         M00_AXI_AWADDR      => M00_AXI_AWADDR,
         M00_AXI_AWBURST     => M00_AXI_AWBURST,
         M00_AXI_AWCACHE     => M00_AXI_AWCACHE,
         M00_AXI_AWID        => M00_AXI_AWID,
         M00_AXI_AWLEN       => M00_AXI_AWLEN,
         M00_AXI_AWLOCK      => M00_AXI_AWLOCK,
         M00_AXI_AWPROT      => M00_AXI_AWPROT,
         M00_AXI_AWQOS       => M00_AXI_AWQOS,
         M00_AXI_AWSIZE      => M00_AXI_AWSIZE,
         M00_AXI_AWUSER      => M00_AXI_AWUSER,
         M00_AXI_AWVALID     => M00_AXI_AWVALID,
         M00_AXI_BREADY      => M00_AXI_BREADY,
         M00_AXI_RREADY      => M00_AXI_RREADY,
         M00_AXI_WDATA       => M00_AXI_WDATA,
         M00_AXI_WLAST       => M00_AXI_WLAST,
         M00_AXI_WSTRB       => M00_AXI_WSTRB,
         M00_AXI_WUSER       => M00_AXI_WUSER,
         M00_AXI_WVALID      => M00_AXI_WVALID,
         clk                 => clk,
         dma_rd_fifosize     => dma_rd_fifosize,
         dma_rdata           => dma_rdata,
         dma_wr_fifosize     => dma_wr_fifosize,
         irq                 => irq,
         reset               => reset,
         s00_axi_arready     => s00_axi_arready,
         s00_axi_awready     => s00_axi_awready,
         s00_axi_bid         => s00_axi_bid,
         s00_axi_bresp       => s00_axi_bresp,
         s00_axi_buser       => s00_axi_buser,
         s00_axi_bvalid      => s00_axi_bvalid,
         s00_axi_rdata       => s00_axi_rdata,
         s00_axi_rid         => s00_axi_rid,
         s00_axi_rlast       => s00_axi_rlast,
         s00_axi_rresp       => s00_axi_rresp,
         s00_axi_ruser       => s00_axi_ruser,
         s00_axi_rvalid      => s00_axi_rvalid,
         s00_axi_wready      => s00_axi_wready,
         sbus_addr           => sbus_addr,
         sbus_be             => sbus_be,
         sbus_rd             => sbus_rd,
         sbus_wdata          => sbus_wdata,
         sbus_we             => sbus_we,
         sync_o              => sync_o,
         xfer_done           => xfer_done
      );

end struct;
