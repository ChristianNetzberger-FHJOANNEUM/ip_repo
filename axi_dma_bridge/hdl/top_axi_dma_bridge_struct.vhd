-- VHDL Entity axi_dma_bridge.top_axi_dma_bridge.symbol
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 09:06:53 07.11.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
library work;
use work.busdef.all;

entity top_axi_dma_bridge is
   generic( 
      C_M00_AXI_ADDR_WIDTH             : integer          := 64;
      C_M00_AXI_ARUSER_WIDTH           : integer          := 0;
      C_M00_AXI_AWUSER_WIDTH           : integer          := 0;
      C_M00_AXI_BURST_LEN              : integer          := 16;
      C_M00_AXI_BUSER_WIDTH            : integer          := 0;
      C_M00_AXI_DATA_WIDTH             : integer          := 64;
      C_M00_AXI_ID_WIDTH               : integer          := 1;
      C_M00_AXI_RUSER_WIDTH            : integer          := 0;
      -- Parameters of Axi Master Bus Interface M00_AXI
      C_M00_AXI_TARGET_SLAVE_BASE_ADDR : std_logic_vector := x"40000000";
      C_M00_AXI_WUSER_WIDTH            : integer          := 0;
      C_S00_AXI_ADDR_WIDTH             : integer          := 18;
      C_S00_AXI_ARUSER_WIDTH           : integer          := 0;
      C_S00_AXI_AWUSER_WIDTH           : integer          := 0;
      C_S00_AXI_BUSER_WIDTH            : integer          := 0;
      C_S00_AXI_DATA_WIDTH             : integer          := 32;
      -- Users to add parameters here
      
      -- User parameters ends
      -- Do not modify the parameters beyond this line
      
      
      -- Parameters of Axi Slave Bus Interface S00_AXI
      C_S00_AXI_ID_WIDTH               : integer          := 1;
      C_S00_AXI_RUSER_WIDTH            : integer          := 0;
      C_S00_AXI_WUSER_WIDTH            : integer          := 0;
      C_SLV_ADDR_WIDTH                 : integer          := 16;
      C_SLV_DATA_WIDTH                 : integer          := 32;
      C_SLOT_NUM                       : integer          := 30;
      C_SYNC_WIDTH                     : integer          := 100;
      C_CORE_CLK_FREQ                  : integer          := 100000000;
      C_USE_TARGET_ADDR_FIFO           : boolean          := false
   );
   port( 
      -- Global Clock Signal.
      M00_AXI_ACLK        : in     std_logic;
      -- Global Reset Singal. This Signal is Active Low
      M00_AXI_ARESETN     : in     std_logic;
      -- Read address ready. This signal indicates that
        -- the slave is ready to accept an address and associated control signals
      M00_AXI_ARREADY     : in     std_logic;
      -- Write address ready. This signal indicates that
        -- the slave is ready to accept an address and associated control signals
      M00_AXI_AWREADY     : in     std_logic;
      -- Master Interface Write Response.
      M00_AXI_BID         : in     std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Write response. This signal indicates the status of the write transaction.
      M00_AXI_BRESP       : in     std_logic_vector (1 downto 0);
      -- Optional User-defined signal in the write response channel
      M00_AXI_BUSER       : in     std_logic_vector (C_M00_AXI_BUSER_WIDTH-1 downto 0);
      -- Write response valid. This signal indicates that the
        -- channel is signaling a valid write response.
      M00_AXI_BVALID      : in     std_logic;
      -- Master Read Data
      M00_AXI_RDATA       : in     std_logic_vector (C_M00_AXI_DATA_WIDTH-1 downto 0);
      -- Read ID tag. This signal is the identification tag
        -- for the read data group of signals generated by the slave.
      M00_AXI_RID         : in     std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Read last. This signal indicates the last transfer in a read burst
      M00_AXI_RLAST       : in     std_logic;
      -- Read response. This signal indicates the status of the read transfer
      M00_AXI_RRESP       : in     std_logic_vector (1 downto 0);
      -- Optional User-defined signal in the read address channel.
      M00_AXI_RUSER       : in     std_logic_vector (C_M00_AXI_RUSER_WIDTH-1 downto 0);
      -- Read valid. This signal indicates that the channel
        -- is signaling the required read data.
      M00_AXI_RVALID      : in     std_logic;
      -- Write ready. This signal indicates that the slave
        -- can accept the write data.
      M00_AXI_WREADY      : in     std_logic;
      dma_rd              : in     std_logic;
      dma_rd_addr         : in     std_logic_vector (31  downto 0);
      dma_rd_mode         : in     std_logic_vector (3  downto 0);
      dma_rd_request_size : in     std_logic_vector (31  downto 0);
      dma_wdata           : in     std_logic_vector (C_M00_AXI_DATA_WIDTH-1  downto 0);
      dma_wr              : in     std_logic;
      dma_wr_addr         : in     std_logic_vector (31  downto 0);
      dma_wr_mode         : in     std_logic_vector (3  downto 0);
      dma_wr_request_size : in     std_logic_vector (31  downto 0);
      -- Users to add ports here
      
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      
      -- Ports of Axi Slave Bus Interface S00_AXI
      s00_axi_aclk        : in     std_logic;
      s00_axi_araddr      : in     std_logic_vector (C_S00_AXI_ADDR_WIDTH-1 downto 0);
      s00_axi_arburst     : in     std_logic_vector (1 downto 0);
      s00_axi_arcache     : in     std_logic_vector (3 downto 0);
      s00_axi_aresetn     : in     std_logic;
      s00_axi_arid        : in     std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_arlen       : in     std_logic_vector (7 downto 0);
      s00_axi_arlock      : in     std_logic;
      s00_axi_arprot      : in     std_logic_vector (2 downto 0);
      s00_axi_arqos       : in     std_logic_vector (3 downto 0);
      s00_axi_arregion    : in     std_logic_vector (3 downto 0);
      s00_axi_arsize      : in     std_logic_vector (2 downto 0);
      s00_axi_aruser      : in     std_logic_vector (C_S00_AXI_ARUSER_WIDTH-1 downto 0);
      s00_axi_arvalid     : in     std_logic;
      s00_axi_awaddr      : in     std_logic_vector (C_S00_AXI_ADDR_WIDTH-1 downto 0);
      s00_axi_awburst     : in     std_logic_vector (1 downto 0);
      s00_axi_awcache     : in     std_logic_vector (3 downto 0);
      s00_axi_awid        : in     std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_awlen       : in     std_logic_vector (7 downto 0);
      s00_axi_awlock      : in     std_logic;
      s00_axi_awprot      : in     std_logic_vector (2 downto 0);
      s00_axi_awqos       : in     std_logic_vector (3 downto 0);
      s00_axi_awregion    : in     std_logic_vector (3 downto 0);
      s00_axi_awsize      : in     std_logic_vector (2 downto 0);
      s00_axi_awuser      : in     std_logic_vector (C_S00_AXI_AWUSER_WIDTH-1 downto 0);
      s00_axi_awvalid     : in     std_logic;
      s00_axi_bready      : in     std_logic;
      s00_axi_rready      : in     std_logic;
      s00_axi_wdata       : in     std_logic_vector (C_S00_AXI_DATA_WIDTH-1 downto 0);
      s00_axi_wlast       : in     std_logic;
      s00_axi_wstrb       : in     std_logic_vector ((C_S00_AXI_DATA_WIDTH/8)-1 downto 0);
      s00_axi_wuser       : in     std_logic_vector (C_S00_AXI_WUSER_WIDTH-1 downto 0);
      s00_axi_wvalid      : in     std_logic;
      sbus_ack            : in     std_logic;
      sbus_rdata          : in     std_logic_vector (31 downto 0);
      sync_i              : in     std_logic_vector (C_SYNC_WIDTH-1 downto 0);
      xfer_sync_ext       : in     std_logic;
      -- Read address. This signal indicates the initial
        -- address of a read burst transaction.
      M00_AXI_ARADDR      : out    std_logic_vector (C_M00_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      M00_AXI_ARBURST     : out    std_logic_vector (1 downto 0);
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      M00_AXI_ARCACHE     : out    std_logic_vector (3 downto 0);
      -- Master Interface Read Address.
      M00_AXI_ARID        : out    std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      M00_AXI_ARLEN       : out    std_logic_vector (7 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      M00_AXI_ARLOCK      : out    std_logic;
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      M00_AXI_ARPROT      : out    std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each read transaction
      M00_AXI_ARQOS       : out    std_logic_vector (3 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      M00_AXI_ARSIZE      : out    std_logic_vector (2 downto 0);
      -- Optional User-defined signal in the read address channel.
      M00_AXI_ARUSER      : out    std_logic_vector (C_M00_AXI_ARUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid read address and control information
      M00_AXI_ARVALID     : out    std_logic;
      -- Master Interface Write Address
      M00_AXI_AWADDR      : out    std_logic_vector (C_M00_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      M00_AXI_AWBURST     : out    std_logic_vector (1 downto 0);
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      M00_AXI_AWCACHE     : out    std_logic_vector (3 downto 0);
      -- Master Interface Write Address ID
      M00_AXI_AWID        : out    std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      M00_AXI_AWLEN       : out    std_logic_vector (7 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      M00_AXI_AWLOCK      : out    std_logic;
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      M00_AXI_AWPROT      : out    std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each write transaction.
      M00_AXI_AWQOS       : out    std_logic_vector (3 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      M00_AXI_AWSIZE      : out    std_logic_vector (2 downto 0);
      -- Optional User-defined signal in the write address channel.
      M00_AXI_AWUSER      : out    std_logic_vector (C_M00_AXI_AWUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid write address and control information.
      M00_AXI_AWVALID     : out    std_logic;
      -- Response ready. This signal indicates that the master
        -- can accept a write response.
      M00_AXI_BREADY      : out    std_logic;
      -- Read ready. This signal indicates that the master can
        -- accept the read data and response information.
      M00_AXI_RREADY      : out    std_logic;
      -- Master Interface Write Data.
      M00_AXI_WDATA       : out    std_logic_vector (C_M00_AXI_DATA_WIDTH-1 downto 0);
      -- Write last. This signal indicates the last transfer in a write burst.
      M00_AXI_WLAST       : out    std_logic;
      -- Write strobes. This signal indicates which byte
        -- lanes hold valid data. There is one write strobe
        -- bit for each eight bits of the write data bus.
      M00_AXI_WSTRB       : out    std_logic_vector (C_M00_AXI_DATA_WIDTH/8-1 downto 0);
      -- Optional User-defined signal in the write data channel.
      M00_AXI_WUSER       : out    std_logic_vector (C_M00_AXI_WUSER_WIDTH-1 downto 0);
      -- Write valid. This signal indicates that valid write
        -- data and strobes are available
      M00_AXI_WVALID      : out    std_logic;
      -- Users to add ports here
      clk                 : out    std_logic;
      dma_rd_fifosize     : out    std_logic_vector (15 downto 0);
      dma_rdata           : out    std_logic_vector (C_M00_AXI_DATA_WIDTH-1  downto 0);
      dma_wr_fifosize     : out    std_logic_vector (15 downto 0);
      irq                 : out    std_logic;
      reset               : out    std_logic;
      s00_axi_arready     : out    std_logic;
      s00_axi_awready     : out    std_logic;
      s00_axi_bid         : out    std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_bresp       : out    std_logic_vector (1 downto 0);
      s00_axi_buser       : out    std_logic_vector (C_S00_AXI_BUSER_WIDTH-1 downto 0);
      s00_axi_bvalid      : out    std_logic;
      s00_axi_rdata       : out    std_logic_vector (C_S00_AXI_DATA_WIDTH-1 downto 0);
      s00_axi_rid         : out    std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_rlast       : out    std_logic;
      s00_axi_rresp       : out    std_logic_vector (1 downto 0);
      s00_axi_ruser       : out    std_logic_vector (C_S00_AXI_RUSER_WIDTH-1 downto 0);
      s00_axi_rvalid      : out    std_logic;
      s00_axi_wready      : out    std_logic;
      sbus_addr           : out    std_logic_vector (15 downto 0);
      sbus_be             : out    std_logic_vector (3 downto 0);
      sbus_rd             : out    std_logic;
      sbus_wdata          : out    std_logic_vector (31 downto 0);
      sbus_we             : out    std_logic;
      sync_o              : out    std_logic_vector (C_SYNC_WIDTH-1 downto 0);
      xfer_done           : out    std_logic
   );

-- Declarations

end top_axi_dma_bridge ;

--
-- VHDL Architecture axi_dma_bridge.top_axi_dma_bridge.struct
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 12:46:34 12.11.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
library work;
use work.busdef.all;

library axi_dma_bridge;

architecture struct of top_axi_dma_bridge is

   -- Architecture declarations

   -- Internal signal declarations
   -- Users to add ports here

-- User ports ends
-- Do not modify the ports beyond this line

-- Initiate AXI transactions
   signal INIT_AXI_RX               : std_logic;
   -- Users to add ports here

-- User ports ends
-- Do not modify the ports beyond this line

-- Initiate AXI transactions
   signal INIT_AXI_TX               : std_logic;
   -- Asserts when transaction is complete
   signal RXN_DONE                  : std_logic;
   -- Asserts when transaction is complete
   signal TXN_DONE                  : std_logic;
   signal ack_cnt                   : std_logic_vector(3 downto 0);
   signal ack_force                 : std_logic;
   signal arcache                   : std_logic_vector(3 downto 0);
   signal awcache                   : std_logic_vector(3 downto 0);
   signal no_of_bursts_req          : std_logic_vector(7 downto 0);
   signal rd_data                   : std_logic_vector(C_M00_AXI_DATA_WIDTH-1  downto 0);
   signal rd_next                   : std_logic;
   signal sbus_i                    : sbus_i_t;
   signal sbus_i_addr               : std_logic_vector(C_SLV_ADDR_WIDTH-1 downto 0);
   signal sbus_i_be                 : std_logic_vector(C_SLV_DATA_WIDTH/8-1 downto 0);
   signal sbus_i_in                 : sbus_i_t;
   signal sbus_i_rd                 : std_logic;
   signal sbus_i_wdata              : std_logic_vector(C_SLV_DATA_WIDTH-1 downto 0);
   --      sbus_i         : out    sbus_i_t;
--      sbus_o         : in     sbus_o_t;
--      dummy          : out    std_logic;
   signal sbus_i_we                 : std_logic;
   signal sbus_o                    : sbus_o_t;
   signal sbus_o_0                  : sbus_o_t;
   signal sbus_o_2                  : sbus_o_t;
   signal sbus_o_3                  : sbus_o_t;
   signal sbus_o_ack                : std_logic;
   signal sbus_o_mux                : sbus_o_t;
   signal sbus_o_null               : sbus_o_t;
   signal sbus_o_rdata              : std_logic_vector(C_SLV_DATA_WIDTH-1 downto 0);
   signal target_slave_base_address : std_logic_vector(31 downto 0);
   signal timer_stb                 : std_logic_vector(7 downto 0);
   signal we_data                   : std_logic_vector(C_M00_AXI_DATA_WIDTH-1  downto 0);
   signal we_next                   : std_logic;

   -- Implicit buffer signal declarations
   signal clk_internal   : std_logic;
   signal reset_internal : std_logic;


-- #pragma translate_on
--attribute mark_debug : string;
--attribute mark_debug of init_axi_rx: signal is "true";
--attribute mark_debug of rxn_done: signal is "true";
--attribute mark_debug of target_slave_base_address: signal is "true";
--attribute mark_debug of rd_next: signal is "true";
--attribute mark_debug of rd_data: signal is "true";

-- #pragma translate_on

   -- Component Declarations
   component M00_AXI
   generic (
      -- Users to add parameters here
      
      -- User parameters ends
      -- Do not modify the parameters beyond this line
      
      -- Base address of targeted slave
      C_M_TARGET_SLAVE_BASE_ADDR : std_logic_vector := x"40000000";
      -- Burst Length. Supports 1, 2, 4, 8, 16, 32, 64, 128, 256 burst lengths
      C_M_AXI_BURST_LEN          : integer          := 16;
      -- Thread ID Width
      C_M_AXI_ID_WIDTH           : integer          := 1;
      -- Width of Address Bus
      C_M_AXI_ADDR_WIDTH         : integer          := 32;
      -- Width of Data Bus
      C_M_AXI_DATA_WIDTH         : integer          := 32;
      -- Width of User Write Address Bus
      C_M_AXI_AWUSER_WIDTH       : integer          := 1;
      -- Width of User Read Address Bus
      C_M_AXI_ARUSER_WIDTH       : integer          := 1;
      -- Width of User Write Data Bus
      C_M_AXI_WUSER_WIDTH        : integer          := 1;
      -- Width of User Read Data Bus
      C_M_AXI_RUSER_WIDTH        : integer          := 1;
      -- Width of User Response Bus
      C_M_AXI_BUSER_WIDTH        : integer          := 1
   );
   port (
      -- Users to add ports here
      
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      -- Initiate AXI transactions
      INIT_AXI_RX               : in     std_logic ;
      -- Users to add ports here
      
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      -- Initiate AXI transactions
      INIT_AXI_TX               : in     std_logic ;
      -- Asserts when transaction is complete
      RXN_DONE                  : out    std_logic ;
      -- Asserts when transaction is complete
      TXN_DONE                  : out    std_logic ;
      -- Asserts when ERROR is detected
      ERROR                     : out    std_logic ;
      -- Global Clock Signal.
      M_AXI_ACLK                : in     std_logic ;
      -- Global Reset Singal. This Signal is Active Low
      M_AXI_ARESETN             : in     std_logic ;
      -- Master Interface Write Address ID
      M_AXI_AWID                : out    std_logic_vector (C_M_AXI_ID_WIDTH-1 downto 0);
      -- Master Interface Write Address
      M_AXI_AWADDR              : out    std_logic_vector (C_M_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      M_AXI_AWLEN               : out    std_logic_vector (7 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      M_AXI_AWSIZE              : out    std_logic_vector (2 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      M_AXI_AWBURST             : out    std_logic_vector (1 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      M_AXI_AWLOCK              : out    std_logic ;
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      M_AXI_AWCACHE             : out    std_logic_vector (3 downto 0);
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      M_AXI_AWPROT              : out    std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each write transaction.
      M_AXI_AWQOS               : out    std_logic_vector (3 downto 0);
      -- Optional User-defined signal in the write address channel.
      M_AXI_AWUSER              : out    std_logic_vector (C_M_AXI_AWUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid write address and control information.
      M_AXI_AWVALID             : out    std_logic ;
      -- Write address ready. This signal indicates that
        -- the slave is ready to accept an address and associated control signals
      M_AXI_AWREADY             : in     std_logic ;
      -- Master Interface Write Data.
      M_AXI_WDATA               : out    std_logic_vector (C_M_AXI_DATA_WIDTH-1 downto 0);
      -- Write strobes. This signal indicates which byte
        -- lanes hold valid data. There is one write strobe
        -- bit for each eight bits of the write data bus.
      M_AXI_WSTRB               : out    std_logic_vector (C_M_AXI_DATA_WIDTH/8-1 downto 0);
      -- Write last. This signal indicates the last transfer in a write burst.
      M_AXI_WLAST               : out    std_logic ;
      -- Optional User-defined signal in the write data channel.
      M_AXI_WUSER               : out    std_logic_vector (C_M_AXI_WUSER_WIDTH-1 downto 0);
      -- Write valid. This signal indicates that valid write
        -- data and strobes are available
      M_AXI_WVALID              : out    std_logic ;
      -- Write ready. This signal indicates that the slave
        -- can accept the write data.
      M_AXI_WREADY              : in     std_logic ;
      -- Master Interface Write Response.
      M_AXI_BID                 : in     std_logic_vector (C_M_AXI_ID_WIDTH-1 downto 0);
      -- Write response. This signal indicates the status of the write transaction.
      M_AXI_BRESP               : in     std_logic_vector (1 downto 0);
      -- Optional User-defined signal in the write response channel
      M_AXI_BUSER               : in     std_logic_vector (C_M_AXI_BUSER_WIDTH-1 downto 0);
      -- Write response valid. This signal indicates that the
        -- channel is signaling a valid write response.
      M_AXI_BVALID              : in     std_logic ;
      -- Response ready. This signal indicates that the master
        -- can accept a write response.
      M_AXI_BREADY              : out    std_logic ;
      -- Master Interface Read Address.
      M_AXI_ARID                : out    std_logic_vector (C_M_AXI_ID_WIDTH-1 downto 0);
      -- Read address. This signal indicates the initial
        -- address of a read burst transaction.
      M_AXI_ARADDR              : out    std_logic_vector (C_M_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      M_AXI_ARLEN               : out    std_logic_vector (7 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      M_AXI_ARSIZE              : out    std_logic_vector (2 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      M_AXI_ARBURST             : out    std_logic_vector (1 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      M_AXI_ARLOCK              : out    std_logic ;
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      M_AXI_ARCACHE             : out    std_logic_vector (3 downto 0);
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      M_AXI_ARPROT              : out    std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each read transaction
      M_AXI_ARQOS               : out    std_logic_vector (3 downto 0);
      -- Optional User-defined signal in the read address channel.
      M_AXI_ARUSER              : out    std_logic_vector (C_M_AXI_ARUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid read address and control information
      M_AXI_ARVALID             : out    std_logic ;
      -- Read address ready. This signal indicates that
        -- the slave is ready to accept an address and associated control signals
      M_AXI_ARREADY             : in     std_logic ;
      -- Read ID tag. This signal is the identification tag
        -- for the read data group of signals generated by the slave.
      M_AXI_RID                 : in     std_logic_vector (C_M_AXI_ID_WIDTH-1 downto 0);
      -- Master Read Data
      M_AXI_RDATA               : in     std_logic_vector (C_M_AXI_DATA_WIDTH-1 downto 0);
      -- Read response. This signal indicates the status of the read transfer
      M_AXI_RRESP               : in     std_logic_vector (1 downto 0);
      -- Read last. This signal indicates the last transfer in a read burst
      M_AXI_RLAST               : in     std_logic ;
      -- Optional User-defined signal in the read address channel.
      M_AXI_RUSER               : in     std_logic_vector (C_M_AXI_RUSER_WIDTH-1 downto 0);
      -- Read valid. This signal indicates that the channel
        -- is signaling the required read data.
      M_AXI_RVALID              : in     std_logic ;
      -- Read ready. This signal indicates that the master can
        -- accept the read data and response information.
      M_AXI_RREADY              : out    std_logic ;
      target_slave_base_address : in     std_logic_vector (31 downto 0);
      no_of_bursts_req          : in     std_logic_vector (7 downto 0);
      we_next                   : out    std_logic ;
      rd_next                   : out    std_logic ;
      we_data                   : in     std_logic_vector (C_M_AXI_DATA_WIDTH-1 downto 0);
      rd_data                   : out    std_logic_vector (C_M_AXI_DATA_WIDTH-1 downto 0);
      arcache                   : in     std_logic_vector (3 downto 0);
      awcache                   : in     std_logic_vector (3 downto 0)
   );
   end component;
   component S00_AXI
   generic (
      -- Users to add parameters here
      pipeline_g           : boolean := false;
      C_SLV_ADDR_WIDTH     : integer := 32;
      C_SLV_DATA_WIDTH     : integer := 32;
      -- User parameters ends
      -- Do not modify the parameters beyond this line
      
      -- Width of ID for for write address, write data, read address and read data
      C_S_AXI_ID_WIDTH     : integer := 1;
      -- Width of S_AXI data bus
      C_S_AXI_DATA_WIDTH   : integer := 32;
      -- Width of S_AXI address bus
      C_S_AXI_ADDR_WIDTH   : integer := 10;
      -- Width of optional user defined signal in write address channel
      C_S_AXI_AWUSER_WIDTH : integer := 1;
      -- Width of optional user defined signal in read address channel
      C_S_AXI_ARUSER_WIDTH : integer := 1;
      -- Width of optional user defined signal in write data channel
      C_S_AXI_WUSER_WIDTH  : integer := 1;
      -- Width of optional user defined signal in read data channel
      C_S_AXI_RUSER_WIDTH  : integer := 1;
      -- Width of optional user defined signal in write response channel
      C_S_AXI_BUSER_WIDTH  : integer := 1
   );
   port (
      -- Users to add ports here
      clk_o          : out    std_logic ;
      reset_o        : out    std_logic ;
      sbus_i_we      : out    std_logic ;
      sbus_i_be      : out    std_logic_vector (C_SLV_DATA_WIDTH/8-1 downto 0);
      sbus_i_rd      : out    std_logic ;
      sbus_o_ack     : in     std_logic ;
      sbus_i_addr    : out    std_logic_vector (C_SLV_ADDR_WIDTH-1 downto 0);
      sbus_i_wdata   : out    std_logic_vector (C_SLV_DATA_WIDTH-1 downto 0);
      sbus_o_rdata   : in     std_logic_vector (C_SLV_DATA_WIDTH-1 downto 0);
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      -- Global Clock Signal
      S_AXI_ACLK     : in     std_logic ;
      -- Global Reset Signal. This Signal is Active LOW
      S_AXI_ARESETN  : in     std_logic ;
      -- Write Address ID
      S_AXI_AWID     : in     std_logic_vector (C_S_AXI_ID_WIDTH-1 downto 0);
      -- Write address
      S_AXI_AWADDR   : in     std_logic_vector (C_S_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      S_AXI_AWLEN    : in     std_logic_vector (7 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      S_AXI_AWSIZE   : in     std_logic_vector (2 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      S_AXI_AWBURST  : in     std_logic_vector (1 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      S_AXI_AWLOCK   : in     std_logic ;
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      S_AXI_AWCACHE  : in     std_logic_vector (3 downto 0);
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      S_AXI_AWPROT   : in     std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each
        -- write transaction.
      S_AXI_AWQOS    : in     std_logic_vector (3 downto 0);
      -- Region identifier. Permits a single physical interface
        -- on a slave to be used for multiple logical interfaces.
      S_AXI_AWREGION : in     std_logic_vector (3 downto 0);
      -- Optional User-defined signal in the write address channel.
      S_AXI_AWUSER   : in     std_logic_vector (C_S_AXI_AWUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid write address and
        -- control information.
      S_AXI_AWVALID  : in     std_logic ;
      -- Write address ready. This signal indicates that
        -- the slave is ready to accept an address and associated
        -- control signals.
      S_AXI_AWREADY  : out    std_logic ;
      -- Write Data
      S_AXI_WDATA    : in     std_logic_vector (C_S_AXI_DATA_WIDTH-1 downto 0);
      -- Write strobes. This signal indicates which byte
        -- lanes hold valid data. There is one write strobe
        -- bit for each eight bits of the write data bus.
      S_AXI_WSTRB    : in     std_logic_vector ((C_S_AXI_DATA_WIDTH/8)-1 downto 0);
      -- Write last. This signal indicates the last transfer
        -- in a write burst.
      S_AXI_WLAST    : in     std_logic ;
      -- Optional User-defined signal in the write data channel.
      S_AXI_WUSER    : in     std_logic_vector (C_S_AXI_WUSER_WIDTH-1 downto 0);
      -- Write valid. This signal indicates that valid write
        -- data and strobes are available.
      S_AXI_WVALID   : in     std_logic ;
      -- Write ready. This signal indicates that the slave
        -- can accept the write data.
      S_AXI_WREADY   : out    std_logic ;
      -- Response ID tag. This signal is the ID tag of the
        -- write response.
      S_AXI_BID      : out    std_logic_vector (C_S_AXI_ID_WIDTH-1 downto 0);
      -- Write response. This signal indicates the status
        -- of the write transaction.
      S_AXI_BRESP    : out    std_logic_vector (1 downto 0);
      -- Optional User-defined signal in the write response channel.
      S_AXI_BUSER    : out    std_logic_vector (C_S_AXI_BUSER_WIDTH-1 downto 0);
      -- Write response valid. This signal indicates that the
        -- channel is signaling a valid write response.
      S_AXI_BVALID   : out    std_logic ;
      -- Response ready. This signal indicates that the master
        -- can accept a write response.
      S_AXI_BREADY   : in     std_logic ;
      -- Read address ID. This signal is the identification
        -- tag for the read address group of signals.
      S_AXI_ARID     : in     std_logic_vector (C_S_AXI_ID_WIDTH-1 downto 0);
      -- Read address. This signal indicates the initial
        -- address of a read burst transaction.
      S_AXI_ARADDR   : in     std_logic_vector (C_S_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      S_AXI_ARLEN    : in     std_logic_vector (7 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      S_AXI_ARSIZE   : in     std_logic_vector (2 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      S_AXI_ARBURST  : in     std_logic_vector (1 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      S_AXI_ARLOCK   : in     std_logic ;
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      S_AXI_ARCACHE  : in     std_logic_vector (3 downto 0);
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      S_AXI_ARPROT   : in     std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each
        -- read transaction.
      S_AXI_ARQOS    : in     std_logic_vector (3 downto 0);
      -- Region identifier. Permits a single physical interface
        -- on a slave to be used for multiple logical interfaces.
      S_AXI_ARREGION : in     std_logic_vector (3 downto 0);
      -- Optional User-defined signal in the read address channel.
      S_AXI_ARUSER   : in     std_logic_vector (C_S_AXI_ARUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid read address and
        -- control information.
      S_AXI_ARVALID  : in     std_logic ;
      -- Read address ready. This signal indicates that
        -- the slave is ready to accept an address and associated
        -- control signals.
      S_AXI_ARREADY  : out    std_logic ;
      -- Read ID tag. This signal is the identification tag
        -- for the read data group of signals generated by the slave.
      S_AXI_RID      : out    std_logic_vector (C_S_AXI_ID_WIDTH-1 downto 0);
      -- Read Data
      S_AXI_RDATA    : out    std_logic_vector (C_S_AXI_DATA_WIDTH-1 downto 0);
      -- Read response. This signal indicates the status of
        -- the read transfer.
      S_AXI_RRESP    : out    std_logic_vector (1 downto 0);
      -- Read last. This signal indicates the last transfer
        -- in a read burst.
      S_AXI_RLAST    : out    std_logic ;
      -- Optional User-defined signal in the read address channel.
      S_AXI_RUSER    : out    std_logic_vector (C_S_AXI_RUSER_WIDTH-1 downto 0);
      -- Read valid. This signal indicates that the channel
        -- is signaling the required read data.
      S_AXI_RVALID   : out    std_logic ;
      -- Read ready. This signal indicates that the master can
        -- accept the read data and response information.
      S_AXI_RREADY   : in     std_logic 
   );
   end component;
   component axi_master_control
   generic (
      C_SLV_ADDR_WIDTH       : integer := 16;
      C_SLV_DATA_WIDTH       : integer := 32;
      C_CORE_CLOCK_FREQ      : integer := 100000000;
      hw_serial_number_g     : integer := 12;
      hw_version_g           : integer := 123;
      C_SYNC_WIDTH           : integer := 16;
      dma_width_g            : integer := 64;
      use_target_addr_fifo_g : boolean := false
   );
   port (
      -- Asserts when transaction is complete
      RXN_DONE                  : in     std_logic ;
      -- Asserts when transaction is complete
      TXN_DONE                  : in     std_logic ;
      clk                       : in     std_logic ;
      dma_rd                    : in     std_logic ;
      dma_rd_addr               : in     std_logic_vector (31  downto 0);
      dma_rd_mode               : in     std_logic_vector (3  downto 0);
      dma_rd_request_size       : in     std_logic_vector (31  downto 0);
      dma_wdata                 : in     std_logic_vector (dma_width_g-1  downto 0);
      dma_wr                    : in     std_logic ;
      dma_wr_addr               : in     std_logic_vector (31  downto 0);
      dma_wr_mode               : in     std_logic_vector (3  downto 0);
      dma_wr_request_size       : in     std_logic_vector (31  downto 0);
      rd_data                   : in     std_logic_vector (dma_width_g-1  downto 0);
      rd_next                   : in     std_logic ;
      reset                     : in     std_logic ;
      sbus_i                    : in     sbus_i_t ;
      sync_i                    : in     std_logic_vector (C_SYNC_WIDTH-1 downto 0);
      we_next                   : in     std_logic ;
      xfer_sync_ext             : in     std_logic ;
      -- Users to add ports here
      
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      -- Initiate AXI transactions
      INIT_AXI_RX               : out    std_logic ;
      -- Users to add ports here
      
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      -- Initiate AXI transactions
      INIT_AXI_TX               : out    std_logic ;
      arcache                   : out    std_logic_vector (3 downto 0);
      awcache                   : out    std_logic_vector (3 downto 0);
      dma_rd_fifosize           : out    std_logic_vector (15 downto 0);
      dma_rdata                 : out    std_logic_vector (dma_width_g-1  downto 0);
      dma_wr_fifosize           : out    std_logic_vector (15 downto 0);
      irq                       : out    std_logic ;
      no_of_bursts_req          : out    std_logic_vector (7 downto 0);
      sbus_o                    : out    sbus_o_t ;
      sync_o                    : out    std_logic_vector (C_SYNC_WIDTH-1 downto 0);
      target_slave_base_address : out    std_logic_vector (31 downto 0);
      we_data                   : out    std_logic_vector (dma_width_g-1  downto 0);
      xfer_done                 : out    std_logic 
   );
   end component;
   component profiler
   generic (
      addr_width_g : integer := 8;      --width of address
      data_width_g : integer := 8;      --width of data
      addr_base_g  : std_logic_vector;
      addr_range_g : std_logic_vector;
      nregs_g      : integer := 16      --number of registers
   );
   port (
      -- Users to add ports here
      clk    : in     std_logic ;
      reset  : in     std_logic ;
      sbus_i : in     sbus_i_t ;
      sbus_o : out    sbus_o_t 
   );
   end component;
   component sbus_mux3
   port (
      clk         : in     std_logic ;
      sbus_i_in   : in     sbus_i_t ;
      sbus_i_out  : out    sbus_i_t ;
      sbus_o_mux  : out    sbus_o_t ;
      sbus_o_0    : in     sbus_o_t ;
      sbus_o_1    : in     sbus_o_t ;
      sbus_o_2    : in     sbus_o_t ;
      sbus_o_3    : in     sbus_o_t ;
      sbus_o_null : out    sbus_o_t 
   );
   end component;

   -- Optional embedded configurations
   -- pragma synthesis_off
   for all : M00_AXI use entity axi_dma_bridge.M00_AXI;
   for all : S00_AXI use entity axi_dma_bridge.S00_AXI;
   for all : axi_master_control use entity axi_dma_bridge.axi_master_control;
   for all : profiler use entity axi_dma_bridge.profiler;
   for all : sbus_mux3 use entity axi_dma_bridge.sbus_mux3;
   -- pragma synthesis_on


begin
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 1 eb1
   sbus_addr <= sbus_i.addr;
   sbus_wdata <= sbus_i.wdata;
   sbus_we <= sbus_i.we;
   sbus_be <= sbus_i.be;
   sbus_rd <= sbus_i.rd;
   sbus_o.rdata <= sbus_rdata;
   sbus_o.ack <= sbus_ack;                                    

   -- HDL Embedded Text Block 2 eb2
   ---slave bus attachment---
   sbus_i_in.addr   <= sbus_i_addr;
   sbus_i_in.wdata <= sbus_i_wdata; 
   sbus_i_in.rd <= sbus_i_rd;
   sbus_i_in.we <= sbus_i_we;
   sbus_i_in.be <= sbus_i_be;
   sbus_o_ack <= sbus_o_mux.ack or ack_force;
   sbus_o_rdata <= sbus_o_mux.rdata;
   
   process(clk_internal)
   begin
     if rising_edge(clk_internal) then
       if reset_internal = '1'  or ack_cnt = 10  or (sbus_i_in.we='0' and sbus_i_in.rd = '0')  then
          ack_cnt <= (others => '0');
       else
          ack_cnt <= ack_cnt+1;
       end if;      
     end if;
   end process;
   
   ack_force <= '1' when ack_cnt >= 9 else '0'; 
                                      
   
   
   


   -- Instance port mappings.
   U_25 : M00_AXI
      generic map (
         -- Users to add parameters here
         
         -- User parameters ends
         -- Do not modify the parameters beyond this line
         
         -- Base address of targeted slave
         C_M_TARGET_SLAVE_BASE_ADDR => x"40000000",
         -- Burst Length. Supports 1, 2, 4, 8, 16, 32, 64, 128, 256 burst lengths
         C_M_AXI_BURST_LEN          => C_M00_AXI_BURST_LEN,
         -- Thread ID Width
         C_M_AXI_ID_WIDTH           => C_M00_AXI_ID_WIDTH,
         -- Width of Address Bus
         C_M_AXI_ADDR_WIDTH         => C_M00_AXI_ADDR_WIDTH,
         -- Width of Data Bus
         C_M_AXI_DATA_WIDTH         => C_M00_AXI_DATA_WIDTH,
         -- Width of User Write Address Bus
         C_M_AXI_AWUSER_WIDTH       => C_M00_AXI_AWUSER_WIDTH,
         -- Width of User Read Address Bus
         C_M_AXI_ARUSER_WIDTH       => C_M00_AXI_ARUSER_WIDTH,
         -- Width of User Write Data Bus
         C_M_AXI_WUSER_WIDTH        => C_M00_AXI_WUSER_WIDTH,
         -- Width of User Read Data Bus
         C_M_AXI_RUSER_WIDTH        => C_M00_AXI_RUSER_WIDTH,
         -- Width of User Response Bus
         C_M_AXI_BUSER_WIDTH        => C_M00_AXI_BUSER_WIDTH
      )
      port map (
         INIT_AXI_RX               => INIT_AXI_RX,
         INIT_AXI_TX               => INIT_AXI_TX,
         RXN_DONE                  => RXN_DONE,
         TXN_DONE                  => TXN_DONE,
         ERROR                     => open,
         M_AXI_ACLK                => M00_AXI_ACLK,
         M_AXI_ARESETN             => M00_AXI_ARESETN,
         M_AXI_AWID                => M00_AXI_AWID,
         M_AXI_AWADDR              => M00_AXI_AWADDR,
         M_AXI_AWLEN               => M00_AXI_AWLEN,
         M_AXI_AWSIZE              => M00_AXI_AWSIZE,
         M_AXI_AWBURST             => M00_AXI_AWBURST,
         M_AXI_AWLOCK              => M00_AXI_AWLOCK,
         M_AXI_AWCACHE             => M00_AXI_AWCACHE,
         M_AXI_AWPROT              => M00_AXI_AWPROT,
         M_AXI_AWQOS               => M00_AXI_AWQOS,
         M_AXI_AWUSER              => M00_AXI_AWUSER,
         M_AXI_AWVALID             => M00_AXI_AWVALID,
         M_AXI_AWREADY             => M00_AXI_AWREADY,
         M_AXI_WDATA               => M00_AXI_WDATA,
         M_AXI_WSTRB               => M00_AXI_WSTRB,
         M_AXI_WLAST               => M00_AXI_WLAST,
         M_AXI_WUSER               => M00_AXI_WUSER,
         M_AXI_WVALID              => M00_AXI_WVALID,
         M_AXI_WREADY              => M00_AXI_WREADY,
         M_AXI_BID                 => M00_AXI_BID,
         M_AXI_BRESP               => M00_AXI_BRESP,
         M_AXI_BUSER               => M00_AXI_BUSER,
         M_AXI_BVALID              => M00_AXI_BVALID,
         M_AXI_BREADY              => M00_AXI_BREADY,
         M_AXI_ARID                => M00_AXI_ARID,
         M_AXI_ARADDR              => M00_AXI_ARADDR,
         M_AXI_ARLEN               => M00_AXI_ARLEN,
         M_AXI_ARSIZE              => M00_AXI_ARSIZE,
         M_AXI_ARBURST             => M00_AXI_ARBURST,
         M_AXI_ARLOCK              => M00_AXI_ARLOCK,
         M_AXI_ARCACHE             => M00_AXI_ARCACHE,
         M_AXI_ARPROT              => M00_AXI_ARPROT,
         M_AXI_ARQOS               => M00_AXI_ARQOS,
         M_AXI_ARUSER              => M00_AXI_ARUSER,
         M_AXI_ARVALID             => M00_AXI_ARVALID,
         M_AXI_ARREADY             => M00_AXI_ARREADY,
         M_AXI_RID                 => M00_AXI_RID,
         M_AXI_RDATA               => M00_AXI_RDATA,
         M_AXI_RRESP               => M00_AXI_RRESP,
         M_AXI_RLAST               => M00_AXI_RLAST,
         M_AXI_RUSER               => M00_AXI_RUSER,
         M_AXI_RVALID              => M00_AXI_RVALID,
         M_AXI_RREADY              => M00_AXI_RREADY,
         target_slave_base_address => target_slave_base_address,
         no_of_bursts_req          => no_of_bursts_req,
         we_next                   => we_next,
         rd_next                   => rd_next,
         we_data                   => we_data,
         rd_data                   => rd_data,
         arcache                   => arcache,
         awcache                   => awcache
      );
   i_S00_AXI : S00_AXI
      generic map (
         -- Users to add parameters here
         pipeline_g           => false,
         C_SLV_ADDR_WIDTH     => C_SLV_ADDR_WIDTH,
         C_SLV_DATA_WIDTH     => C_SLV_DATA_WIDTH,
         -- User parameters ends
         -- Do not modify the parameters beyond this line
         
         -- Width of ID for for write address, write data, read address and read data
         C_S_AXI_ID_WIDTH     => C_S00_AXI_ID_WIDTH,
         -- Width of S_AXI data bus
         C_S_AXI_DATA_WIDTH   => C_S00_AXI_DATA_WIDTH,
         -- Width of S_AXI address bus
         C_S_AXI_ADDR_WIDTH   => C_S00_AXI_ADDR_WIDTH,
         -- Width of optional user defined signal in write address channel
         C_S_AXI_AWUSER_WIDTH => C_S00_AXI_AWUSER_WIDTH,
         -- Width of optional user defined signal in read address channel
         C_S_AXI_ARUSER_WIDTH => C_S00_AXI_ARUSER_WIDTH,
         -- Width of optional user defined signal in write data channel
         C_S_AXI_WUSER_WIDTH  => C_S00_AXI_WUSER_WIDTH,
         -- Width of optional user defined signal in read data channel
         C_S_AXI_RUSER_WIDTH  => C_S00_AXI_RUSER_WIDTH,
         -- Width of optional user defined signal in write response channel
         C_S_AXI_BUSER_WIDTH  => C_S00_AXI_BUSER_WIDTH
      )
      port map (
         clk_o          => clk_internal,
         reset_o        => reset_internal,
         sbus_i_we      => sbus_i_we,
         sbus_i_be      => sbus_i_be,
         sbus_i_rd      => sbus_i_rd,
         sbus_o_ack     => sbus_o_ack,
         sbus_i_addr    => sbus_i_addr,
         sbus_i_wdata   => sbus_i_wdata,
         sbus_o_rdata   => sbus_o_rdata,
         S_AXI_ACLK     => s00_axi_aclk,
         S_AXI_ARESETN  => s00_axi_aresetn,
         S_AXI_AWID     => s00_axi_awid,
         S_AXI_AWADDR   => s00_axi_awaddr,
         S_AXI_AWLEN    => s00_axi_awlen,
         S_AXI_AWSIZE   => s00_axi_awsize,
         S_AXI_AWBURST  => s00_axi_awburst,
         S_AXI_AWLOCK   => s00_axi_awlock,
         S_AXI_AWCACHE  => s00_axi_awcache,
         S_AXI_AWPROT   => s00_axi_awprot,
         S_AXI_AWQOS    => s00_axi_awqos,
         S_AXI_AWREGION => s00_axi_awregion,
         S_AXI_AWUSER   => s00_axi_awuser,
         S_AXI_AWVALID  => s00_axi_awvalid,
         S_AXI_AWREADY  => s00_axi_awready,
         S_AXI_WDATA    => s00_axi_wdata,
         S_AXI_WSTRB    => s00_axi_wstrb,
         S_AXI_WLAST    => s00_axi_wlast,
         S_AXI_WUSER    => s00_axi_wuser,
         S_AXI_WVALID   => s00_axi_wvalid,
         S_AXI_WREADY   => s00_axi_wready,
         S_AXI_BID      => s00_axi_bid,
         S_AXI_BRESP    => s00_axi_bresp,
         S_AXI_BUSER    => s00_axi_buser,
         S_AXI_BVALID   => s00_axi_bvalid,
         S_AXI_BREADY   => s00_axi_bready,
         S_AXI_ARID     => s00_axi_arid,
         S_AXI_ARADDR   => s00_axi_araddr,
         S_AXI_ARLEN    => s00_axi_arlen,
         S_AXI_ARSIZE   => s00_axi_arsize,
         S_AXI_ARBURST  => s00_axi_arburst,
         S_AXI_ARLOCK   => s00_axi_arlock,
         S_AXI_ARCACHE  => s00_axi_arcache,
         S_AXI_ARPROT   => s00_axi_arprot,
         S_AXI_ARQOS    => s00_axi_arqos,
         S_AXI_ARREGION => s00_axi_arregion,
         S_AXI_ARUSER   => s00_axi_aruser,
         S_AXI_ARVALID  => s00_axi_arvalid,
         S_AXI_ARREADY  => s00_axi_arready,
         S_AXI_RID      => s00_axi_rid,
         S_AXI_RDATA    => s00_axi_rdata,
         S_AXI_RRESP    => s00_axi_rresp,
         S_AXI_RLAST    => s00_axi_rlast,
         S_AXI_RUSER    => s00_axi_ruser,
         S_AXI_RVALID   => s00_axi_rvalid,
         S_AXI_RREADY   => s00_axi_rready
      );
   i_topcon : axi_master_control
      generic map (
         C_SLV_ADDR_WIDTH       => 16,
         C_SLV_DATA_WIDTH       => 32,
         C_CORE_CLOCK_FREQ      => C_CORE_CLK_FREQ,
         hw_serial_number_g     => 12,
         hw_version_g           => 30,
         C_SYNC_WIDTH           => C_SYNC_WIDTH,
         dma_width_g            => C_M00_AXI_DATA_WIDTH,
         use_target_addr_fifo_g => C_USE_TARGET_ADDR_FIFO
      )
      port map (
         RXN_DONE                  => RXN_DONE,
         TXN_DONE                  => TXN_DONE,
         clk                       => clk_internal,
         dma_rd                    => dma_rd,
         dma_rd_addr               => dma_rd_addr,
         dma_rd_mode               => dma_rd_mode,
         dma_rd_request_size       => dma_rd_request_size,
         dma_wdata                 => dma_wdata,
         dma_wr                    => dma_wr,
         dma_wr_addr               => dma_wr_addr,
         dma_wr_mode               => dma_wr_mode,
         dma_wr_request_size       => dma_wr_request_size,
         rd_data                   => rd_data,
         rd_next                   => rd_next,
         reset                     => reset_internal,
         sbus_i                    => sbus_i,
         sync_i                    => sync_i,
         we_next                   => we_next,
         xfer_sync_ext             => xfer_sync_ext,
         INIT_AXI_RX               => INIT_AXI_RX,
         INIT_AXI_TX               => INIT_AXI_TX,
         arcache                   => arcache,
         awcache                   => awcache,
         dma_rd_fifosize           => dma_rd_fifosize,
         dma_rdata                 => dma_rdata,
         dma_wr_fifosize           => dma_wr_fifosize,
         irq                       => irq,
         no_of_bursts_req          => no_of_bursts_req,
         sbus_o                    => sbus_o_0,
         sync_o                    => sync_o,
         target_slave_base_address => target_slave_base_address,
         we_data                   => we_data,
         xfer_done                 => xfer_done
      );
   U_4 : profiler
      generic map (
         addr_width_g => 16,         --width of address
         data_width_g => 32,         --width of data
         addr_base_g  => X"0200",
         addr_range_g => X"0008",
         nregs_g      => 8           --number of registers
      )
      port map (
         clk    => clk_internal,
         reset  => reset_internal,
         sbus_i => sbus_i,
         sbus_o => sbus_o_3
      );
   U_3 : sbus_mux3
      port map (
         clk         => clk_internal,
         sbus_i_in   => sbus_i_in,
         sbus_i_out  => sbus_i,
         sbus_o_mux  => sbus_o_mux,
         sbus_o_0    => sbus_o_0,
         sbus_o_1    => sbus_o,
         sbus_o_2    => sbus_o_2,
         sbus_o_3    => sbus_o_3,
         sbus_o_null => sbus_o_null
      );

   g0: IF false GENERATE
   begin
      -- HDL Embedded Text Block 3 for_debug
      --some debugging signals---
      process(init_axi_rx,rxn_done,target_slave_base_address,rd_data,rd_next)
      begin
      sync_o <= (others => '0'); 
      sync_o(63 downto 0) <= rd_data(63 downto 0); 
      sync_o(95 downto 64) <= target_slave_base_address;
      sync_o(96) <= init_axi_rx;
      sync_o(97) <= rxn_done;
      sync_o(98) <= rd_next;
      end process;                                 
      

   end generate g0;

   -- Implicit buffered output assignments
   clk   <= clk_internal;
   reset <= reset_internal;

end struct;
