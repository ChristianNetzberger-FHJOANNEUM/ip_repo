-- VHDL Entity axi_dma_bridge.fifo_stream_ctrl.symbol
--
-- Created:
--          by - Net.UNKNOWN (KPERSM7467)
--          at - 09:35:20 21.08.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
library ieee;
use ieee.std_logic_1164.ALL;
use ieee.std_logic_arith.ALL;
use ieee.std_logic_unsigned.all;
library work;
use work.busdef.all;

entity fifo_stream_ctrl is
   port( 
      clk           : in     std_logic;
      fifo_rd       : in     std_logic;
      fifo_rd_en    : in     std_logic;
      fifo_rd_size  : in     std_logic_vector (15 downto 0);
      fifo_wr_en    : in     std_logic;
      fifo_wr_size  : in     std_logic_vector (15 downto 0);
      rd_threshold  : in     std_logic_vector (15 downto 0);
      reset         : in     std_logic;
      wr_threshold  : in     std_logic_vector (15 downto 0);
      xfer_done     : in     std_logic;
      xfer_rd_en    : in     std_logic;
      xfer_wr_en    : in     std_logic;
      fifo_wr_flush : out    std_logic;
      xfer_rd_init  : out    std_logic;
      xfer_wr_init  : out    std_logic
   );

-- Declarations

end fifo_stream_ctrl ;

--
-- VHDL Architecture axi_dma_bridge.fifo_stream_ctrl.fsm
--
-- Created:
--          by - Net.UNKNOWN (KPERSM7467)
--          at - 09:35:37 21.08.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
library ieee;
use ieee.std_logic_1164.ALL;
use ieee.std_logic_arith.ALL;
use ieee.std_logic_unsigned.all;
library work;
use work.busdef.all;
 
architecture fsm of fifo_stream_ctrl is

   -- Architecture Declarations
   signal wr_flush: std_logic;
   signal reset_wr_flush: std_logic;

   type state_type is (
      s_reset,
      s_wait,
      s_xfer,
      s_xfer1
   );
 
   -- Declare current and next state signals
   signal current_state : state_type;
   signal next_state : state_type;

   -- Declare any pre-registered internal signals
   signal xfer_rd_init_cld : std_logic ;
   signal xfer_wr_init_cld : std_logic ;

begin

   -----------------------------------------------------------------
   clocked_proc : process ( 
      clk
   )
   -----------------------------------------------------------------
   begin
      if (clk'event and clk = '1') then
         if (reset = '1') then
            current_state <= s_reset;
            -- Default Reset Values
            xfer_rd_init_cld <= '0';
            xfer_wr_init_cld <= '0';
         else
            current_state <= next_state;
            -- Default Assignment To Internals
            xfer_rd_init_cld <= '0';
            xfer_wr_init_cld <= '0';

            -- Combined Actions
            case current_state is
               when s_wait => 
                  if ((fifo_rd_size < rd_threshold) and xfer_rd_en = '1' and fifo_rd_en = '1') then 
                     xfer_rd_init_cld <= '1';
                  elsif (((fifo_wr_size >= wr_threshold) and xfer_wr_en = '1') or wr_flush = '1') then 
                     xfer_wr_init_cld <= '1';
                  end if;
               when s_xfer => 
                  if (((xfer_done = '1' or xfer_rd_en = '0') and ((fifo_wr_size > wr_threshold) and xfer_wr_en = '1')) or wr_flush = '1') then 
                     xfer_wr_init_cld <= '1';
                  end if;
               when others =>
                  null;
            end case;
         end if;
      end if;
   end process clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : process ( 
      current_state,
      fifo_rd_en,
      fifo_rd_size,
      fifo_wr_size,
      rd_threshold,
      wr_flush,
      wr_threshold,
      xfer_done,
      xfer_rd_en,
      xfer_wr_en
   )
   -----------------------------------------------------------------
   begin
      case current_state is
         when s_reset => 
            next_state <= s_wait;
         when s_wait => 
            if ((fifo_rd_size < rd_threshold) and xfer_rd_en = '1' and fifo_rd_en = '1') then 
               next_state <= s_xfer;
            elsif (((fifo_wr_size >= wr_threshold) and xfer_wr_en = '1') or wr_flush = '1') then 
               next_state <= s_xfer1;
            else
               next_state <= s_wait;
            end if;
         when s_xfer => 
            if (((xfer_done = '1' or xfer_rd_en = '0') and ((fifo_wr_size > wr_threshold) and xfer_wr_en = '1')) or wr_flush = '1') then 
               next_state <= s_xfer1;
            elsif (xfer_done = '1' or xfer_rd_en = '0') then 
               next_state <= s_wait;
            else
               next_state <= s_xfer;
            end if;
         when s_xfer1 => 
            if (xfer_done = '1' or (xfer_wr_en = '0' and wr_flush = '0')) then 
               next_state <= s_wait;
            else
               next_state <= s_xfer1;
            end if;
         when others =>
            next_state <= s_reset;
      end case;
   end process nextstate_proc;
 
   -- Concurrent Statements
   -- Clocked output assignments
   xfer_rd_init <= xfer_rd_init_cld;
   xfer_wr_init <= xfer_wr_init_cld;
   process(clk)
      variable q: std_logic;
   begin
      if rising_edge(clk) then
         if q = '1' and fifo_wr_en = '0' then
                if fifo_wr_size /= 0 then
                   wr_flush <= '1';
                end if;
        elsif fifo_wr_size = 0 then
             wr_flush <= '0';
        end if;
        q := fifo_wr_en;
      end if;
   end process;
   
   fifo_wr_flush <= fifo_wr_en when fifo_wr_size = 0 else '1';
end fsm;
