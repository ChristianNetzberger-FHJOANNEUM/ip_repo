-- VHDL Entity axi_dma_bridge.tb_top.symbol
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 19:04:13 13.03.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

entity tb_top is
   generic( 
      -- Width of Address Bus
      C_M00_AXI_ADDR_WIDTH   : integer := 32;
      -- Width of User Read Address Bus
      C_M00_AXI_ARUSER_WIDTH : integer := 1;
      -- Width of User Write Address Bus
      C_M00_AXI_AWUSER_WIDTH : integer := 1;
      -- Burst Length. Supports 1, 2, 4, 8, 16, 32, 64, 128, 256 burst lengths
      C_M00_AXI_BURST_LEN    : integer := 16;
      -- Width of User Response Bus
      C_M00_AXI_BUSER_WIDTH  : integer := 1;
      -- Width of Data Bus
      C_M00_AXI_DATA_WIDTH   : integer := 64;
      -- Thread ID Width
      C_M00_AXI_ID_WIDTH     : integer := 12;
      -- Width of User Read Data Bus
      C_M00_AXI_RUSER_WIDTH  : integer := 1;
      -- Width of User Write Data Bus
      C_M00_AXI_WUSER_WIDTH  : integer := 1;
      -- Width of Address Bus
      C_M01_AXI_ADDR_WIDTH   : integer := 32;
      -- Width of User Read Address Bus
      C_M01_AXI_ARUSER_WIDTH : integer := 1;
      -- Width of User Write Address Bus
      C_M01_AXI_AWUSER_WIDTH : integer := 1;
      -- Burst Length. Supports 1, 2, 4, 8, 16, 32, 64, 128, 256 burst lengths
      C_M01_AXI_BURST_LEN    : integer := 4;
      -- Width of User Response Bus
      C_M01_AXI_BUSER_WIDTH  : integer := 1;
      -- Width of Data Bus
      C_M01_AXI_DATA_WIDTH   : integer := 64;
      -- Thread ID Width
      C_M01_AXI_ID_WIDTH     : integer := 12;
      -- Width of User Read Data Bus
      C_M01_AXI_RUSER_WIDTH  : integer := 1;
      -- Width of User Write Data Bus
      C_M01_AXI_WUSER_WIDTH  : integer := 1;
      C_S00_AXI_ADDR_WIDTH   : integer := 18;
      C_S00_AXI_ARUSER_WIDTH : integer := 1;
      C_S00_AXI_AWUSER_WIDTH : integer := 1;
      C_S00_AXI_BUSER_WIDTH  : integer := 1;
      C_S00_AXI_DATA_WIDTH   : integer := 32;
      -- Users to add parameters here
      
      -- User parameters ends
      -- Do not modify the parameters beyond this line
      
      
      -- Parameters of Axi Slave Bus Interface S00_AXI
      C_S00_AXI_ID_WIDTH     : integer := 12;
      C_S00_AXI_RUSER_WIDTH  : integer := 1;
      C_S00_AXI_WUSER_WIDTH  : integer := 1;
      C_SLV_ADDR_WIDTH       : integer := 16;
      C_SLV_DATA_WIDTH       : integer := 32;
      C_SYNC_WIDTH           : integer := 8
   );
-- Declarations

end tb_top ;

--
-- VHDL Architecture axi_dma_bridge.tb_top.struct
--
-- Created:
--          by - Net.UNKNOWN (KPERSM7467)
--          at - 09:53:37 21.08.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
library work;
use work.busdef.all;

library axi_dma_bridge;

architecture struct of tb_top is

   -- Architecture declarations

   -- Internal signal declarations
   -- Read address. This signal indicates the initial
  -- address of a read burst transaction.
   signal M00_AXI_ARADDR      : std_logic_vector(C_M00_AXI_ADDR_WIDTH-1 downto 0);
   -- Burst type. The burst type and the size information,
  -- determine how the address for each transfer within the burst is calculated.
   signal M00_AXI_ARBURST     : std_logic_vector(1 downto 0);
   -- Memory type. This signal indicates how transactions
  -- are required to progress through a system.
   signal M00_AXI_ARCACHE     : std_logic_vector(3 downto 0);
   -- Master Interface Read Address.
   signal M00_AXI_ARID        : std_logic_vector(C_M00_AXI_ID_WIDTH-1 downto 0);
   -- Burst length. The burst length gives the exact number of transfers in a burst
   signal M00_AXI_ARLEN       : std_logic_vector(7 downto 0);
   -- Lock type. Provides additional information about the
  -- atomic characteristics of the transfer.
   signal M00_AXI_ARLOCK      : std_logic;
   -- Protection type. This signal indicates the privilege
  -- and security level of the transaction, and whether
  -- the transaction is a data access or an instruction access.
   signal M00_AXI_ARPROT      : std_logic_vector(2 downto 0);
   -- Quality of Service, QoS identifier sent for each read transaction
   signal M00_AXI_ARQOS       : std_logic_vector(3 downto 0);
   -- Read address ready. This signal indicates that
  -- the slave is ready to accept an address and associated control signals
   signal M00_AXI_ARREADY     : std_logic;
   -- Burst size. This signal indicates the size of each transfer in the burst
   signal M00_AXI_ARSIZE      : std_logic_vector(2 downto 0);
   -- Optional User-defined signal in the read address channel.
   signal M00_AXI_ARUSER      : std_logic_vector(C_M00_AXI_ARUSER_WIDTH-1 downto 0);
   -- Write address valid. This signal indicates that
  -- the channel is signaling valid read address and control information
   signal M00_AXI_ARVALID     : std_logic;
   -- Master Interface Write Address
   signal M00_AXI_AWADDR      : std_logic_vector(C_M00_AXI_ADDR_WIDTH-1 downto 0);
   -- Burst type. The burst type and the size information,
  -- determine how the address for each transfer within the burst is calculated.
   signal M00_AXI_AWBURST     : std_logic_vector(1 downto 0);
   -- Memory type. This signal indicates how transactions
  -- are required to progress through a system.
   signal M00_AXI_AWCACHE     : std_logic_vector(3 downto 0);
   -- Master Interface Write Address ID
   signal M00_AXI_AWID        : std_logic_vector(C_M00_AXI_ID_WIDTH-1 downto 0);
   -- Burst length. The burst length gives the exact number of transfers in a burst
   signal M00_AXI_AWLEN       : std_logic_vector(7 downto 0);
   -- Lock type. Provides additional information about the
  -- atomic characteristics of the transfer.
   signal M00_AXI_AWLOCK      : std_logic;
   -- Protection type. This signal indicates the privilege
  -- and security level of the transaction, and whether
  -- the transaction is a data access or an instruction access.
   signal M00_AXI_AWPROT      : std_logic_vector(2 downto 0);
   -- Quality of Service, QoS identifier sent for each write transaction.
   signal M00_AXI_AWQOS       : std_logic_vector(3 downto 0);
   -- Write address ready. This signal indicates that
  -- the slave is ready to accept an address and associated control signals
   signal M00_AXI_AWREADY     : std_logic;
   -- Burst size. This signal indicates the size of each transfer in the burst
   signal M00_AXI_AWSIZE      : std_logic_vector(2 downto 0);
   -- Optional User-defined signal in the write address channel.
   signal M00_AXI_AWUSER      : std_logic_vector(C_M00_AXI_AWUSER_WIDTH-1 downto 0);
   -- Write address valid. This signal indicates that
  -- the channel is signaling valid write address and control information.
   signal M00_AXI_AWVALID     : std_logic;
   -- Master Interface Write Response.
   signal M00_AXI_BID         : std_logic_vector(C_M00_AXI_ID_WIDTH-1 downto 0);
   -- Response ready. This signal indicates that the master
  -- can accept a write response.
   signal M00_AXI_BREADY      : std_logic;
   -- Write response. This signal indicates the status of the write transaction.
   signal M00_AXI_BRESP       : std_logic_vector(1 downto 0);
   -- Optional User-defined signal in the write response channel
   signal M00_AXI_BUSER       : std_logic_vector(C_M00_AXI_BUSER_WIDTH-1 downto 0);
   -- Write response valid. This signal indicates that the
  -- channel is signaling a valid write response.
   signal M00_AXI_BVALID      : std_logic;
   -- Master Read Data
   signal M00_AXI_RDATA       : std_logic_vector(C_M00_AXI_DATA_WIDTH-1 downto 0);
   -- Read ID tag. This signal is the identification tag
  -- for the read data group of signals generated by the slave.
   signal M00_AXI_RID         : std_logic_vector(C_M00_AXI_ID_WIDTH-1 downto 0);
   -- Read last. This signal indicates the last transfer in a read burst
   signal M00_AXI_RLAST       : std_logic;
   -- Read ready. This signal indicates that the master can
  -- accept the read data and response information.
   signal M00_AXI_RREADY      : std_logic;
   -- Read response. This signal indicates the status of the read transfer
   signal M00_AXI_RRESP       : std_logic_vector(1 downto 0);
   -- Optional User-defined signal in the read address channel.
   signal M00_AXI_RUSER       : std_logic_vector(C_M00_AXI_RUSER_WIDTH-1 downto 0);
   -- Read valid. This signal indicates that the channel
  -- is signaling the required read data.
   signal M00_AXI_RVALID      : std_logic;
   -- Master Interface Write Data.
   signal M00_AXI_WDATA       : std_logic_vector(C_M00_AXI_DATA_WIDTH-1 downto 0);
   -- Write last. This signal indicates the last transfer in a write burst.
   signal M00_AXI_WLAST       : std_logic;
   -- Write ready. This signal indicates that the slave
  -- can accept the write data.
   signal M00_AXI_WREADY      : std_logic;
   -- Write strobes. This signal indicates which byte
  -- lanes hold valid data. There is one write strobe
  -- bit for each eight bits of the write data bus.
   signal M00_AXI_WSTRB       : std_logic_vector(C_M00_AXI_DATA_WIDTH/8-1 downto 0);
   -- Optional User-defined signal in the write data channel.
   signal M00_AXI_WUSER       : std_logic_vector(C_M00_AXI_WUSER_WIDTH-1 downto 0);
   -- Write valid. This signal indicates that valid write
  -- data and strobes are available
   signal M00_AXI_WVALID      : std_logic;
   signal S_AXI_ARREGION      : std_logic_vector(3 downto 0);
   signal S_AXI_AWREGION      : std_logic_vector(3 downto 0);
   -- User ports ends
-- Do not modify the ports beyond this line


-- Ports of Axi Slave Bus Interface S00_AXI
   signal clk                 : std_logic;
   signal dma_wr_request_size : std_logic_vector(31  downto 0);
   signal fifo_rd             : std_logic;
   signal fifo_wdata          : std_logic_vector(63 downto 0);
   signal fifo_we             : std_logic;
   signal hi                  : std_logic;
   signal hi4                 : std_logic_vector(3 downto 0);
   signal lo                  : std_logic;
   signal lo32                : std_logic_vector(31 downto 0);
   signal load2mem            : std_logic;
   signal reset               : std_logic;
   -- User ports ends
-- Do not modify the ports beyond this line


-- Ports of Axi Slave Bus Interface S00_AXI
   signal s00_axi_aclk        : std_logic;
   signal s00_axi_araddr      : std_logic_vector(C_S00_AXI_ADDR_WIDTH-1 downto 0);
   signal s00_axi_arburst     : std_logic_vector(1 downto 0);
   signal s00_axi_arcache     : std_logic_vector(3 downto 0);
   signal s00_axi_aresetn     : std_logic;
   signal s00_axi_arid        : std_logic_vector(C_S00_AXI_ID_WIDTH-1 downto 0);
   signal s00_axi_arlen       : std_logic_vector(7 downto 0);
   signal s00_axi_arlock      : std_logic;
   signal s00_axi_arprot      : std_logic_vector(2 downto 0);
   signal s00_axi_arqos       : std_logic_vector(3 downto 0);
   signal s00_axi_arready     : std_logic;
   signal s00_axi_arregion    : std_logic_vector(3 downto 0);
   signal s00_axi_arsize      : std_logic_vector(2 downto 0);
   signal s00_axi_aruser      : std_logic_vector(C_S00_AXI_ARUSER_WIDTH-1 downto 0);
   signal s00_axi_arvalid     : std_logic;
   signal s00_axi_awaddr      : std_logic_vector(C_S00_AXI_ADDR_WIDTH-1 downto 0);
   signal s00_axi_awburst     : std_logic_vector(1 downto 0);
   signal s00_axi_awcache     : std_logic_vector(3 downto 0);
   signal s00_axi_awid        : std_logic_vector(C_S00_AXI_ID_WIDTH-1 downto 0);
   signal s00_axi_awlen       : std_logic_vector(7 downto 0);
   signal s00_axi_awlock      : std_logic;
   signal s00_axi_awprot      : std_logic_vector(2 downto 0);
   signal s00_axi_awqos       : std_logic_vector(3 downto 0);
   signal s00_axi_awready     : std_logic;
   signal s00_axi_awregion    : std_logic_vector(3 downto 0);
   signal s00_axi_awsize      : std_logic_vector(2 downto 0);
   signal s00_axi_awuser      : std_logic_vector(C_S00_AXI_AWUSER_WIDTH-1 downto 0);
   signal s00_axi_awvalid     : std_logic;
   signal s00_axi_bid         : std_logic_vector(C_S00_AXI_ID_WIDTH-1 downto 0);
   signal s00_axi_bready      : std_logic;
   signal s00_axi_bresp       : std_logic_vector(1 downto 0);
   signal s00_axi_buser       : std_logic_vector(C_S00_AXI_BUSER_WIDTH-1 downto 0);
   signal s00_axi_bvalid      : std_logic;
   signal s00_axi_rdata       : std_logic_vector(C_S00_AXI_DATA_WIDTH-1 downto 0);
   signal s00_axi_rid         : std_logic_vector(C_S00_AXI_ID_WIDTH-1 downto 0);
   signal s00_axi_rlast       : std_logic;
   signal s00_axi_rready      : std_logic;
   signal s00_axi_rresp       : std_logic_vector(1 downto 0);
   signal s00_axi_ruser       : std_logic_vector(C_S00_AXI_RUSER_WIDTH-1 downto 0);
   signal s00_axi_rvalid      : std_logic;
   signal s00_axi_wdata       : std_logic_vector(C_S00_AXI_DATA_WIDTH-1 downto 0);
   signal s00_axi_wlast       : std_logic;
   signal s00_axi_wready      : std_logic;
   signal s00_axi_wstrb       : std_logic_vector((C_S00_AXI_DATA_WIDTH/8)-1 downto 0);
   signal s00_axi_wuser       : std_logic_vector(C_S00_AXI_WUSER_WIDTH-1 downto 0);
   signal s00_axi_wvalid      : std_logic;
   signal save2file           : std_logic;
   signal sbus_ack            : std_logic;
   signal sbus_addr           : std_logic_vector(15 downto 0);
   signal sbus_o_null         : sbus_o_t;
   signal sbus_rd             : std_logic;
   signal sbus_rdata          : std_logic_vector(31 downto 0);
   signal sbus_wdata          : std_logic_vector(31 downto 0);
   signal sbus_we             : std_logic;
   signal sync_i              : std_logic_vector(C_SYNC_WIDTH-1 downto 0);
   signal sync_o              : std_logic_vector(C_SYNC_WIDTH-1 downto 0);
   signal testdata            : std_logic_vector(15 downto 0);


   -- Component Declarations
   component axi_slave64
   generic (
      -- Width of Address Bus
      C_M00_AXI_ADDR_WIDTH   : integer := 32;
      -- Width of User Read Address Bus
      C_M00_AXI_ARUSER_WIDTH : integer := 1;
      -- Width of User Write Address Bus
      C_M00_AXI_AWUSER_WIDTH : integer := 1;
      -- Burst Length. Supports 1, 2, 4, 8, 16, 32, 64, 128, 256 burst lengths
      C_M00_AXI_BURST_LEN    : integer := 16;
      -- Width of User Response Bus
      C_M00_AXI_BUSER_WIDTH  : integer := 1;
      -- Width of Data Bus
      C_M00_AXI_DATA_WIDTH   : integer := 64;
      -- Thread ID Width
      C_M00_AXI_ID_WIDTH     : integer := 12;
      -- Width of User Read Data Bus
      C_M00_AXI_RUSER_WIDTH  : integer := 1;
      -- Width of User Write Data Bus
      C_M00_AXI_WUSER_WIDTH  : integer := 1;
      C_S00_AXI_ADDR_WIDTH   : integer := 18;
      C_S00_AXI_ARUSER_WIDTH : integer := 1;
      C_S00_AXI_AWUSER_WIDTH : integer := 1;
      C_S00_AXI_BUSER_WIDTH  : integer := 1;
      C_S00_AXI_DATA_WIDTH   : integer := 32;
      -- Users to add parameters here
      
      -- User parameters ends
      -- Do not modify the parameters beyond this line
      
      
      -- Parameters of Axi Slave Bus Interface S00_AXI
      C_S00_AXI_ID_WIDTH     : integer := 12;
      C_S00_AXI_RUSER_WIDTH  : integer := 1;
      C_S00_AXI_WUSER_WIDTH  : integer := 1;
      read_file_g            : string  := "read_file.txt";
      write_file_g           : string  := "write_file.txt"
   );
   port (
      -- Read address. This signal indicates the initial
        -- address of a read burst transaction.
      M_AXI_ARADDR    : in     std_logic_vector (C_M00_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      M_AXI_ARBURST   : in     std_logic_vector (1 downto 0);
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      M_AXI_ARCACHE   : in     std_logic_vector (3 downto 0);
      -- Master Interface Read Address.
      M_AXI_ARID      : in     std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      M_AXI_ARLEN     : in     std_logic_vector (7 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      M_AXI_ARLOCK    : in     std_logic ;
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      M_AXI_ARPROT    : in     std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each read transaction
      M_AXI_ARQOS     : in     std_logic_vector (3 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      M_AXI_ARSIZE    : in     std_logic_vector (2 downto 0);
      -- Optional User-defined signal in the read address channel.
      M_AXI_ARUSER    : in     std_logic_vector (C_M00_AXI_ARUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid read address and control information
      M_AXI_ARVALID   : in     std_logic ;
      -- Master Interface Write Address
      M_AXI_AWADDR    : in     std_logic_vector (C_M00_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      M_AXI_AWBURST   : in     std_logic_vector (1 downto 0);
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      M_AXI_AWCACHE   : in     std_logic_vector (3 downto 0);
      -- Master Interface Write Address ID
      M_AXI_AWID      : in     std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      M_AXI_AWLEN     : in     std_logic_vector (7 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      M_AXI_AWLOCK    : in     std_logic ;
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      M_AXI_AWPROT    : in     std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each write transaction.
      M_AXI_AWQOS     : in     std_logic_vector (3 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      M_AXI_AWSIZE    : in     std_logic_vector (2 downto 0);
      -- Optional User-defined signal in the write address channel.
      M_AXI_AWUSER    : in     std_logic_vector (C_M00_AXI_AWUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid write address and control information.
      M_AXI_AWVALID   : in     std_logic ;
      -- Response ready. This signal indicates that the master
        -- can accept a write response.
      M_AXI_BREADY    : in     std_logic ;
      -- Read ready. This signal indicates that the master can
        -- accept the read data and response information.
      M_AXI_RREADY    : in     std_logic ;
      -- Master Interface Write Data.
      M_AXI_WDATA     : in     std_logic_vector (C_M00_AXI_DATA_WIDTH-1 downto 0);
      -- Write last. This signal indicates the last transfer in a write burst.
      M_AXI_WLAST     : in     std_logic ;
      -- Write strobes. This signal indicates which byte
        -- lanes hold valid data. There is one write strobe
        -- bit for each eight bits of the write data bus.
      M_AXI_WSTRB     : in     std_logic_vector (C_M00_AXI_DATA_WIDTH/8-1 downto 0);
      -- Optional User-defined signal in the write data channel.
      M_AXI_WUSER     : in     std_logic_vector (C_M00_AXI_WUSER_WIDTH-1 downto 0);
      -- Write valid. This signal indicates that valid write
        -- data and strobes are available
      M_AXI_WVALID    : in     std_logic ;
      S_AXI_ARREGION  : in     std_logic_vector (3 downto 0);
      S_AXI_AWREGION  : in     std_logic_vector (3 downto 0);
      load2mem        : in     std_logic ;
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      
      -- Ports of Axi Slave Bus Interface S00_AXI
      s00_axi_aclk    : in     std_logic ;
      s00_axi_aresetn : in     std_logic ;
      save2file       : in     std_logic ;
      -- Read address ready. This signal indicates that
        -- the slave is ready to accept an address and associated control signals
      M_AXI_ARREADY   : out    std_logic ;
      -- Write address ready. This signal indicates that
        -- the slave is ready to accept an address and associated control signals
      M_AXI_AWREADY   : out    std_logic ;
      -- Master Interface Write Response.
      M_AXI_BID       : out    std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Write response. This signal indicates the status of the write transaction.
      M_AXI_BRESP     : out    std_logic_vector (1 downto 0);
      -- Optional User-defined signal in the write response channel
      M_AXI_BUSER     : out    std_logic_vector (C_M00_AXI_BUSER_WIDTH-1 downto 0);
      -- Write response valid. This signal indicates that the
        -- channel is signaling a valid write response.
      M_AXI_BVALID    : out    std_logic ;
      -- Master Read Data
      M_AXI_RDATA     : out    std_logic_vector (C_M00_AXI_DATA_WIDTH-1 downto 0);
      -- Read ID tag. This signal is the identification tag
        -- for the read data group of signals generated by the slave.
      M_AXI_RID       : out    std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Read last. This signal indicates the last transfer in a read burst
      M_AXI_RLAST     : out    std_logic ;
      -- Read response. This signal indicates the status of the read transfer
      M_AXI_RRESP     : out    std_logic_vector (1 downto 0);
      -- Optional User-defined signal in the read address channel.
      M_AXI_RUSER     : out    std_logic_vector (C_M00_AXI_RUSER_WIDTH-1 downto 0);
      -- Read valid. This signal indicates that the channel
        -- is signaling the required read data.
      M_AXI_RVALID    : out    std_logic ;
      -- Write ready. This signal indicates that the slave
        -- can accept the write data.
      M_AXI_WREADY    : out    std_logic 
   );
   end component;
   component cnt_modulus
   generic (
      n_dout_g : integer := 8;
      module_g : integer := 256
   );
   port (
      clk    : in     std_logic ;
      enable : in     std_logic ;
      reset  : in     std_logic ;
      dout   : out    std_logic_vector (n_dout_g-1 downto 0);
      cnt_tc : out    std_logic 
   );
   end component;
   component sbus_termination
   port (
      sbus_i_null : out    sbus_i_t;
      sbus_o_null : out    sbus_o_t
   );
   end component;
   component test_axi_mst
   generic (
      C_S00_AXI_ADDR_WIDTH   : integer := 6;
      C_S00_AXI_ARUSER_WIDTH : integer := 1;
      C_S00_AXI_AWUSER_WIDTH : integer := 1;
      C_S00_AXI_BUSER_WIDTH  : integer := 1;
      C_S00_AXI_DATA_WIDTH   : integer := 32;
      -- Users to add parameters here
      
      -- User parameters ends
      -- Do not modify the parameters beyond this line
      
      
      -- Parameters of Axi Slave Bus Interface S00_AXI
      C_S00_AXI_ID_WIDTH     : integer := 1;
      C_S00_AXI_RUSER_WIDTH  : integer := 1;
      C_S00_AXI_WUSER_WIDTH  : integer := 1;
      clk_period_g           : time    := 8ps;
      COMMANDS               : string  := "buscommands.txt"
   );
   port (
      s00_axi_arready  : in     std_logic ;
      s00_axi_awready  : in     std_logic ;
      s00_axi_bid      : in     std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_bresp    : in     std_logic_vector (1 downto 0);
      s00_axi_buser    : in     std_logic_vector (C_S00_AXI_BUSER_WIDTH-1 downto 0);
      s00_axi_bvalid   : in     std_logic ;
      s00_axi_rdata    : in     std_logic_vector (C_S00_AXI_DATA_WIDTH-1 downto 0);
      s00_axi_rid      : in     std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_rlast    : in     std_logic ;
      s00_axi_rresp    : in     std_logic_vector (1 downto 0);
      s00_axi_ruser    : in     std_logic_vector (C_S00_AXI_RUSER_WIDTH-1 downto 0);
      s00_axi_rvalid   : in     std_logic ;
      s00_axi_wready   : in     std_logic ;
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      
      -- Ports of Axi Slave Bus Interface S00_AXI
      s00_axi_aclk     : out    std_logic ;
      s00_axi_araddr   : out    std_logic_vector (C_S00_AXI_ADDR_WIDTH-1 downto 0);
      s00_axi_arburst  : out    std_logic_vector (1 downto 0);
      s00_axi_arcache  : out    std_logic_vector (3 downto 0);
      s00_axi_aresetn  : out    std_logic ;
      s00_axi_arid     : out    std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_arlen    : out    std_logic_vector (7 downto 0);
      s00_axi_arlock   : out    std_logic ;
      s00_axi_arprot   : out    std_logic_vector (2 downto 0);
      s00_axi_arqos    : out    std_logic_vector (3 downto 0);
      s00_axi_arregion : out    std_logic_vector (3 downto 0);
      s00_axi_arsize   : out    std_logic_vector (2 downto 0);
      s00_axi_aruser   : out    std_logic_vector (C_S00_AXI_ARUSER_WIDTH-1 downto 0);
      s00_axi_arvalid  : out    std_logic ;
      s00_axi_awaddr   : out    std_logic_vector (C_S00_AXI_ADDR_WIDTH-1 downto 0);
      s00_axi_awburst  : out    std_logic_vector (1 downto 0);
      s00_axi_awcache  : out    std_logic_vector (3 downto 0);
      s00_axi_awid     : out    std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_awlen    : out    std_logic_vector (7 downto 0);
      s00_axi_awlock   : out    std_logic ;
      s00_axi_awprot   : out    std_logic_vector (2 downto 0);
      s00_axi_awqos    : out    std_logic_vector (3 downto 0);
      s00_axi_awregion : out    std_logic_vector (3 downto 0);
      s00_axi_awsize   : out    std_logic_vector (2 downto 0);
      s00_axi_awuser   : out    std_logic_vector (C_S00_AXI_AWUSER_WIDTH-1 downto 0);
      s00_axi_awvalid  : out    std_logic ;
      s00_axi_bready   : out    std_logic ;
      s00_axi_rready   : out    std_logic ;
      s00_axi_wdata    : out    std_logic_vector (C_S00_AXI_DATA_WIDTH-1 downto 0);
      s00_axi_wlast    : out    std_logic ;
      s00_axi_wstrb    : out    std_logic_vector ((C_S00_AXI_DATA_WIDTH/8)-1 downto 0);
      s00_axi_wuser    : out    std_logic_vector (C_S00_AXI_WUSER_WIDTH-1 downto 0);
      s00_axi_wvalid   : out    std_logic 
   );
   end component;
   component to_sbus
   port (
      sbus_ack   : out    std_logic ;
      sbus_rd    : in     std_logic ;
      sbus_we    : in     std_logic ;
      sbus_addr  : in     std_logic_vector (15 downto 0);
      sbus_i     : out    sbus_i_t ;
      sbus_o     : in     sbus_o_t ;
      sbus_rdata : out    std_logic_vector (31 downto 0);
      sbus_wdata : in     std_logic_vector (31 downto 0)
   );
   end component;
   component top_signal_connector_v1_0
   generic (
      C_M00_AXI_ADDR_WIDTH             : integer          := 32;
      C_M00_AXI_ARUSER_WIDTH           : integer          := 0;
      C_M00_AXI_AWUSER_WIDTH           : integer          := 0;
      C_M00_AXI_BURST_LEN              : integer          := 16;
      C_M00_AXI_BUSER_WIDTH            : integer          := 0;
      C_M00_AXI_DATA_WIDTH             : integer          := 64;
      C_M00_AXI_ID_WIDTH               : integer          := 1;
      C_M00_AXI_RUSER_WIDTH            : integer          := 0;
      -- Parameters of Axi Master Bus Interface M00_AXI
      C_M00_AXI_TARGET_SLAVE_BASE_ADDR : std_logic_vector := x"40000000";
      C_M00_AXI_WUSER_WIDTH            : integer          := 0;
      C_S00_AXI_ADDR_WIDTH             : integer          := 10;
      C_S00_AXI_ARUSER_WIDTH           : integer          := 0;
      C_S00_AXI_AWUSER_WIDTH           : integer          := 0;
      C_S00_AXI_BUSER_WIDTH            : integer          := 0;
      C_S00_AXI_DATA_WIDTH             : integer          := 32;
      -- Users to add parameters here
      
      -- User parameters ends
      -- Do not modify the parameters beyond this line
      
      
      -- Parameters of Axi Slave Bus Interface S00_AXI
      C_S00_AXI_ID_WIDTH               : integer          := 1;
      C_S00_AXI_RUSER_WIDTH            : integer          := 0;
      C_S00_AXI_WUSER_WIDTH            : integer          := 0;
      C_SLV_ADDR_WIDTH                 : integer          := 16;
      C_SLV_DATA_WIDTH                 : integer          := 32;
      C_SYNC_WidTH                     : integer          := 8
   );
   port (
      -- Global Clock Signal.
      M00_AXI_ACLK        : in     std_logic ;
      -- Global Reset Singal. This Signal is Active Low
      M00_AXI_ARESETN     : in     std_logic ;
      -- Read address ready. This signal indicates that
        -- the slave is ready to accept an address and associated control signals
      M00_AXI_ARREADY     : in     std_logic ;
      -- Write address ready. This signal indicates that
        -- the slave is ready to accept an address and associated control signals
      M00_AXI_AWREADY     : in     std_logic ;
      -- Master Interface Write Response.
      M00_AXI_BID         : in     std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Write response. This signal indicates the status of the write transaction.
      M00_AXI_BRESP       : in     std_logic_vector (1 downto 0);
      -- Optional User-defined signal in the write response channel
      M00_AXI_BUSER       : in     std_logic_vector (C_M00_AXI_BUSER_WIDTH-1 downto 0);
      -- Write response valid. This signal indicates that the
        -- channel is signaling a valid write response.
      M00_AXI_BVALID      : in     std_logic ;
      -- Master Read Data
      M00_AXI_RDATA       : in     std_logic_vector (C_M00_AXI_DATA_WIDTH-1 downto 0);
      -- Read ID tag. This signal is the identification tag
        -- for the read data group of signals generated by the slave.
      M00_AXI_RID         : in     std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Read last. This signal indicates the last transfer in a read burst
      M00_AXI_RLAST       : in     std_logic ;
      -- Read response. This signal indicates the status of the read transfer
      M00_AXI_RRESP       : in     std_logic_vector (1 downto 0);
      -- Optional User-defined signal in the read address channel.
      M00_AXI_RUSER       : in     std_logic_vector (C_M00_AXI_RUSER_WIDTH-1 downto 0);
      -- Read valid. This signal indicates that the channel
        -- is signaling the required read data.
      M00_AXI_RVALID      : in     std_logic ;
      -- Write ready. This signal indicates that the slave
        -- can accept the write data.
      M00_AXI_WREADY      : in     std_logic ;
      dma_rd              : in     std_logic ;
      dma_rd_addr         : in     std_logic_vector (31  downto 0);
      dma_rd_mode         : in     std_logic_vector (3  downto 0);
      dma_rd_request_size : in     std_logic_vector (31  downto 0);
      dma_wdata           : in     std_logic_vector (C_M00_AXI_DATA_WIDTH-1  downto 0);
      dma_wr              : in     std_logic ;
      dma_wr_addr         : in     std_logic_vector (31  downto 0);
      dma_wr_mode         : in     std_logic_vector (3  downto 0);
      dma_wr_request_size : in     std_logic_vector (31  downto 0);
      -- Users to add ports here
      
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      
      -- Ports of Axi Slave Bus Interface S00_AXI
      s00_axi_aclk        : in     std_logic ;
      s00_axi_araddr      : in     std_logic_vector (C_S00_AXI_ADDR_WIDTH-1 downto 0);
      s00_axi_arburst     : in     std_logic_vector (1 downto 0);
      s00_axi_arcache     : in     std_logic_vector (3 downto 0);
      s00_axi_aresetn     : in     std_logic ;
      s00_axi_arid        : in     std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_arlen       : in     std_logic_vector (7 downto 0);
      s00_axi_arlock      : in     std_logic ;
      s00_axi_arprot      : in     std_logic_vector (2 downto 0);
      s00_axi_arqos       : in     std_logic_vector (3 downto 0);
      s00_axi_arregion    : in     std_logic_vector (3 downto 0);
      s00_axi_arsize      : in     std_logic_vector (2 downto 0);
      s00_axi_aruser      : in     std_logic_vector (C_S00_AXI_ARUSER_WIDTH-1 downto 0);
      s00_axi_arvalid     : in     std_logic ;
      s00_axi_awaddr      : in     std_logic_vector (C_S00_AXI_ADDR_WIDTH-1 downto 0);
      s00_axi_awburst     : in     std_logic_vector (1 downto 0);
      s00_axi_awcache     : in     std_logic_vector (3 downto 0);
      s00_axi_awid        : in     std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_awlen       : in     std_logic_vector (7 downto 0);
      s00_axi_awlock      : in     std_logic ;
      s00_axi_awprot      : in     std_logic_vector (2 downto 0);
      s00_axi_awqos       : in     std_logic_vector (3 downto 0);
      s00_axi_awregion    : in     std_logic_vector (3 downto 0);
      s00_axi_awsize      : in     std_logic_vector (2 downto 0);
      s00_axi_awuser      : in     std_logic_vector (C_S00_AXI_AWUSER_WIDTH-1 downto 0);
      s00_axi_awvalid     : in     std_logic ;
      s00_axi_bready      : in     std_logic ;
      s00_axi_rready      : in     std_logic ;
      s00_axi_wdata       : in     std_logic_vector (C_S00_AXI_DATA_WIDTH-1 downto 0);
      s00_axi_wlast       : in     std_logic ;
      s00_axi_wstrb       : in     std_logic_vector ((C_S00_AXI_DATA_WIDTH/8)-1 downto 0);
      s00_axi_wuser       : in     std_logic_vector (C_S00_AXI_WUSER_WIDTH-1 downto 0);
      s00_axi_wvalid      : in     std_logic ;
      sbus_ack            : in     std_logic ;
      sbus_rdata          : in     std_logic_vector (31 downto 0);
      sync_i              : in     std_logic_vector (C_SYNC_WIDTH-1 downto 0);
      xfer_sync_ext       : in     std_logic ;
      -- Read address. This signal indicates the initial
        -- address of a read burst transaction.
      M00_AXI_ARADDR      : out    std_logic_vector (C_M00_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      M00_AXI_ARBURST     : out    std_logic_vector (1 downto 0);
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      M00_AXI_ARCACHE     : out    std_logic_vector (3 downto 0);
      -- Master Interface Read Address.
      M00_AXI_ARID        : out    std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      M00_AXI_ARLEN       : out    std_logic_vector (7 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      M00_AXI_ARLOCK      : out    std_logic ;
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      M00_AXI_ARPROT      : out    std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each read transaction
      M00_AXI_ARQOS       : out    std_logic_vector (3 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      M00_AXI_ARSIZE      : out    std_logic_vector (2 downto 0);
      -- Optional User-defined signal in the read address channel.
      M00_AXI_ARUSER      : out    std_logic_vector (C_M00_AXI_ARUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid read address and control information
      M00_AXI_ARVALID     : out    std_logic ;
      -- Master Interface Write Address
      M00_AXI_AWADDR      : out    std_logic_vector (C_M00_AXI_ADDR_WIDTH-1 downto 0);
      -- Burst type. The burst type and the size information,
        -- determine how the address for each transfer within the burst is calculated.
      M00_AXI_AWBURST     : out    std_logic_vector (1 downto 0);
      -- Memory type. This signal indicates how transactions
        -- are required to progress through a system.
      M00_AXI_AWCACHE     : out    std_logic_vector (3 downto 0);
      -- Master Interface Write Address ID
      M00_AXI_AWID        : out    std_logic_vector (C_M00_AXI_ID_WIDTH-1 downto 0);
      -- Burst length. The burst length gives the exact number of transfers in a burst
      M00_AXI_AWLEN       : out    std_logic_vector (7 downto 0);
      -- Lock type. Provides additional information about the
        -- atomic characteristics of the transfer.
      M00_AXI_AWLOCK      : out    std_logic ;
      -- Protection type. This signal indicates the privilege
        -- and security level of the transaction, and whether
        -- the transaction is a data access or an instruction access.
      M00_AXI_AWPROT      : out    std_logic_vector (2 downto 0);
      -- Quality of Service, QoS identifier sent for each write transaction.
      M00_AXI_AWQOS       : out    std_logic_vector (3 downto 0);
      -- Burst size. This signal indicates the size of each transfer in the burst
      M00_AXI_AWSIZE      : out    std_logic_vector (2 downto 0);
      -- Optional User-defined signal in the write address channel.
      M00_AXI_AWUSER      : out    std_logic_vector (C_M00_AXI_AWUSER_WIDTH-1 downto 0);
      -- Write address valid. This signal indicates that
        -- the channel is signaling valid write address and control information.
      M00_AXI_AWVALID     : out    std_logic ;
      -- Response ready. This signal indicates that the master
        -- can accept a write response.
      M00_AXI_BREADY      : out    std_logic ;
      -- Read ready. This signal indicates that the master can
        -- accept the read data and response information.
      M00_AXI_RREADY      : out    std_logic ;
      -- Master Interface Write Data.
      M00_AXI_WDATA       : out    std_logic_vector (C_M00_AXI_DATA_WIDTH-1 downto 0);
      -- Write last. This signal indicates the last transfer in a write burst.
      M00_AXI_WLAST       : out    std_logic ;
      -- Write strobes. This signal indicates which byte
        -- lanes hold valid data. There is one write strobe
        -- bit for each eight bits of the write data bus.
      M00_AXI_WSTRB       : out    std_logic_vector (C_M00_AXI_DATA_WIDTH/8-1 downto 0);
      -- Optional User-defined signal in the write data channel.
      M00_AXI_WUSER       : out    std_logic_vector (C_M00_AXI_WUSER_WIDTH-1 downto 0);
      -- Write valid. This signal indicates that valid write
        -- data and strobes are available
      M00_AXI_WVALID      : out    std_logic ;
      dma_rd_fifosize     : out    std_logic_vector (15 downto 0);
      dma_rdata           : out    std_logic_vector (C_M00_AXI_DATA_WIDTH-1  downto 0);
      dma_wr_fifosize     : out    std_logic_vector (15 downto 0);
      irq                 : out    std_logic ;
      s00_axi_arready     : out    std_logic ;
      s00_axi_awready     : out    std_logic ;
      s00_axi_bid         : out    std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_bresp       : out    std_logic_vector (1 downto 0);
      s00_axi_buser       : out    std_logic_vector (C_S00_AXI_BUSER_WIDTH-1 downto 0);
      s00_axi_bvalid      : out    std_logic ;
      s00_axi_rdata       : out    std_logic_vector (C_S00_AXI_DATA_WIDTH-1 downto 0);
      s00_axi_rid         : out    std_logic_vector (C_S00_AXI_ID_WIDTH-1 downto 0);
      s00_axi_rlast       : out    std_logic ;
      s00_axi_rresp       : out    std_logic_vector (1 downto 0);
      s00_axi_ruser       : out    std_logic_vector (C_S00_AXI_RUSER_WIDTH-1 downto 0);
      s00_axi_rvalid      : out    std_logic ;
      s00_axi_wready      : out    std_logic ;
      sbus_addr           : out    std_logic_vector (15 downto 0);
      sbus_be             : out    std_logic_vector (3 downto 0);
      sbus_rd             : out    std_logic ;
      sbus_wdata          : out    std_logic_vector (31 downto 0);
      sbus_we             : out    std_logic ;
      sync_o              : out    std_logic_vector (C_SYNC_WIDTH-1 downto 0);
      xfer_done           : out    std_logic 
   );
   end component;

   -- Optional embedded configurations
   -- pragma synthesis_off
   for all : axi_slave64 use entity axi_dma_bridge.axi_slave64;
   for all : cnt_modulus use entity axi_dma_bridge.cnt_modulus;
   for all : sbus_termination use entity axi_dma_bridge.sbus_termination;
   for all : test_axi_mst use entity axi_dma_bridge.test_axi_mst;
   for all : to_sbus use entity axi_dma_bridge.to_sbus;
   for all : top_signal_connector_v1_0 use entity axi_dma_bridge.top_signal_connector_v1_0;
   -- pragma synthesis_on


begin
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 2 eb2
   clk <= s00_axi_aclk;
   reset <= not s00_axi_aresetn;                          

   -- HDL Embedded Text Block 3 eb3
   process
   begin
     save2file <= '0';
     wait for 4000 us;
     save2file <= '1';
     wait;
   end process;     
   load2mem <= '0';                     

   -- HDL Embedded Text Block 4 eb4
   fifo_wdata <= X"12345678" & (not testdata) & testdata;                                 

   -- HDL Embedded Text Block 5 eb5
   dma_wr_request_size <= (others => '0');
   hi4 <= (others => '1');
   reset <= not s00_axi_aresetn;                          

   -- HDL Embedded Text Block 10 constant_values3
   -- constant logic values
   hi <= '1';
   lo <= '0';                                     


   -- Instance port mappings.
   U_6 : axi_slave64
      generic map (
         -- Width of Address Bus
         C_M00_AXI_ADDR_WIDTH   => 32,
         -- Width of User Read Address Bus
         C_M00_AXI_ARUSER_WIDTH => 1,
         -- Width of User Write Address Bus
         C_M00_AXI_AWUSER_WIDTH => 1,
         -- Burst Length. Supports 1, 2, 4, 8, 16, 32, 64, 128, 256 burst lengths
         C_M00_AXI_BURST_LEN    => 16,
         -- Width of User Response Bus
         C_M00_AXI_BUSER_WIDTH  => 1,
         -- Width of Data Bus
         C_M00_AXI_DATA_WIDTH   => 64,
         -- Thread ID Width
         C_M00_AXI_ID_WIDTH     => 12,
         -- Width of User Read Data Bus
         C_M00_AXI_RUSER_WIDTH  => 1,
         -- Width of User Write Data Bus
         C_M00_AXI_WUSER_WIDTH  => 1,
         C_S00_AXI_ADDR_WIDTH   => 18,
         C_S00_AXI_ARUSER_WIDTH => 1,
         C_S00_AXI_AWUSER_WIDTH => 1,
         C_S00_AXI_BUSER_WIDTH  => 1,
         C_S00_AXI_DATA_WIDTH   => 32,
         -- Users to add parameters here
         
         -- User parameters ends
         -- Do not modify the parameters beyond this line
         
         
         -- Parameters of Axi Slave Bus Interface S00_AXI
         C_S00_AXI_ID_WIDTH     => 12,
         C_S00_AXI_RUSER_WIDTH  => 1,
         C_S00_AXI_WUSER_WIDTH  => 1,
         read_file_g            => "read_file.txt",
         write_file_g           => "write_file.txt"
      )
      port map (
         M_AXI_ARADDR    => M00_AXI_ARADDR,
         M_AXI_ARBURST   => M00_AXI_ARBURST,
         M_AXI_ARCACHE   => M00_AXI_ARCACHE,
         M_AXI_ARID      => M00_AXI_ARID,
         M_AXI_ARLEN     => M00_AXI_ARLEN,
         M_AXI_ARLOCK    => M00_AXI_ARLOCK,
         M_AXI_ARPROT    => M00_AXI_ARPROT,
         M_AXI_ARQOS     => M00_AXI_ARQOS,
         M_AXI_ARSIZE    => M00_AXI_ARSIZE,
         M_AXI_ARUSER    => M00_AXI_ARUSER,
         M_AXI_ARVALID   => M00_AXI_ARVALID,
         M_AXI_AWADDR    => M00_AXI_AWADDR,
         M_AXI_AWBURST   => M00_AXI_AWBURST,
         M_AXI_AWCACHE   => M00_AXI_AWCACHE,
         M_AXI_AWID      => M00_AXI_AWID,
         M_AXI_AWLEN     => M00_AXI_AWLEN,
         M_AXI_AWLOCK    => M00_AXI_AWLOCK,
         M_AXI_AWPROT    => M00_AXI_AWPROT,
         M_AXI_AWQOS     => M00_AXI_AWQOS,
         M_AXI_AWSIZE    => M00_AXI_AWSIZE,
         M_AXI_AWUSER    => M00_AXI_AWUSER,
         M_AXI_AWVALID   => M00_AXI_AWVALID,
         M_AXI_BREADY    => M00_AXI_BREADY,
         M_AXI_RREADY    => M00_AXI_RREADY,
         M_AXI_WDATA     => M00_AXI_WDATA,
         M_AXI_WLAST     => M00_AXI_WLAST,
         M_AXI_WSTRB     => M00_AXI_WSTRB,
         M_AXI_WUSER     => M00_AXI_WUSER,
         M_AXI_WVALID    => M00_AXI_WVALID,
         S_AXI_ARREGION  => S_AXI_ARREGION,
         S_AXI_AWREGION  => S_AXI_AWREGION,
         load2mem        => load2mem,
         s00_axi_aclk    => s00_axi_aclk,
         s00_axi_aresetn => s00_axi_aresetn,
         save2file       => save2file,
         M_AXI_ARREADY   => M00_AXI_ARREADY,
         M_AXI_AWREADY   => M00_AXI_AWREADY,
         M_AXI_BID       => M00_AXI_BID,
         M_AXI_BRESP     => M00_AXI_BRESP,
         M_AXI_BUSER     => M00_AXI_BUSER,
         M_AXI_BVALID    => M00_AXI_BVALID,
         M_AXI_RDATA     => M00_AXI_RDATA,
         M_AXI_RID       => M00_AXI_RID,
         M_AXI_RLAST     => M00_AXI_RLAST,
         M_AXI_RRESP     => M00_AXI_RRESP,
         M_AXI_RUSER     => M00_AXI_RUSER,
         M_AXI_RVALID    => M00_AXI_RVALID,
         M_AXI_WREADY    => M00_AXI_WREADY
      );
   U_2 : cnt_modulus
      generic map (
         n_dout_g => 8,
         module_g => 256
      )
      port map (
         clk    => clk,
         enable => hi,
         reset  => reset,
         dout   => open,
         cnt_tc => fifo_we
      );
   U_3 : cnt_modulus
      generic map (
         n_dout_g => 9,
         module_g => 400
      )
      port map (
         clk    => clk,
         enable => hi,
         reset  => reset,
         dout   => open,
         cnt_tc => fifo_rd
      );
   U_4 : cnt_modulus
      generic map (
         n_dout_g => 16,
         module_g => 2**16
      )
      port map (
         clk    => clk,
         enable => fifo_we,
         reset  => reset,
         dout   => testdata,
         cnt_tc => open
      );
   U_7 : sbus_termination
      port map (
         sbus_o_null => sbus_o_null,
         sbus_i_null => open
      );
   U_1 : test_axi_mst
      generic map (
         C_S00_AXI_ADDR_WIDTH   => C_S00_AXI_ADDR_WIDTH,
         C_S00_AXI_ARUSER_WIDTH => C_S00_AXI_ARUSER_WIDTH,
         C_S00_AXI_AWUSER_WIDTH => C_S00_AXI_AWUSER_WIDTH,
         C_S00_AXI_BUSER_WIDTH  => C_S00_AXI_BUSER_WIDTH,
         C_S00_AXI_DATA_WIDTH   => C_S00_AXI_DATA_WIDTH,
         -- Users to add parameters here
         
         -- User parameters ends
         -- Do not modify the parameters beyond this line
         
         
         -- Parameters of Axi Slave Bus Interface S00_AXI
         C_S00_AXI_ID_WIDTH     => C_S00_AXI_ID_WIDTH,
         C_S00_AXI_RUSER_WIDTH  => C_S00_AXI_RUSER_WIDTH,
         C_S00_AXI_WUSER_WIDTH  => C_S00_AXI_WUSER_WIDTH,
         clk_period_g           => 10 ns,
         COMMANDS               => "buscommands.txt"
      )
      port map (
         s00_axi_arready  => s00_axi_arready,
         s00_axi_awready  => s00_axi_awready,
         s00_axi_bid      => s00_axi_bid,
         s00_axi_bresp    => s00_axi_bresp,
         s00_axi_buser    => s00_axi_buser,
         s00_axi_bvalid   => s00_axi_bvalid,
         s00_axi_rdata    => s00_axi_rdata,
         s00_axi_rid      => s00_axi_rid,
         s00_axi_rlast    => s00_axi_rlast,
         s00_axi_rresp    => s00_axi_rresp,
         s00_axi_ruser    => s00_axi_ruser,
         s00_axi_rvalid   => s00_axi_rvalid,
         s00_axi_wready   => s00_axi_wready,
         s00_axi_aclk     => s00_axi_aclk,
         s00_axi_araddr   => s00_axi_araddr,
         s00_axi_arburst  => s00_axi_arburst,
         s00_axi_arcache  => s00_axi_arcache,
         s00_axi_aresetn  => s00_axi_aresetn,
         s00_axi_arid     => s00_axi_arid,
         s00_axi_arlen    => s00_axi_arlen,
         s00_axi_arlock   => s00_axi_arlock,
         s00_axi_arprot   => s00_axi_arprot,
         s00_axi_arqos    => s00_axi_arqos,
         s00_axi_arregion => s00_axi_arregion,
         s00_axi_arsize   => s00_axi_arsize,
         s00_axi_aruser   => s00_axi_aruser,
         s00_axi_arvalid  => s00_axi_arvalid,
         s00_axi_awaddr   => s00_axi_awaddr,
         s00_axi_awburst  => s00_axi_awburst,
         s00_axi_awcache  => s00_axi_awcache,
         s00_axi_awid     => s00_axi_awid,
         s00_axi_awlen    => s00_axi_awlen,
         s00_axi_awlock   => s00_axi_awlock,
         s00_axi_awprot   => s00_axi_awprot,
         s00_axi_awqos    => s00_axi_awqos,
         s00_axi_awregion => s00_axi_awregion,
         s00_axi_awsize   => s00_axi_awsize,
         s00_axi_awuser   => s00_axi_awuser,
         s00_axi_awvalid  => s00_axi_awvalid,
         s00_axi_bready   => s00_axi_bready,
         s00_axi_rready   => s00_axi_rready,
         s00_axi_wdata    => s00_axi_wdata,
         s00_axi_wlast    => s00_axi_wlast,
         s00_axi_wstrb    => s00_axi_wstrb,
         s00_axi_wuser    => s00_axi_wuser,
         s00_axi_wvalid   => s00_axi_wvalid
      );
   U_5 : to_sbus
      port map (
         sbus_ack   => sbus_ack,
         sbus_rd    => sbus_rd,
         sbus_we    => sbus_we,
         sbus_addr  => sbus_addr,
         sbus_i     => open,
         sbus_o     => sbus_o_null,
         sbus_rdata => sbus_rdata,
         sbus_wdata => sbus_wdata
      );
   U_0 : top_signal_connector_v1_0
      generic map (
         C_M00_AXI_ADDR_WIDTH             => C_M00_AXI_ADDR_WIDTH,
         C_M00_AXI_ARUSER_WIDTH           => C_M00_AXI_ARUSER_WIDTH,
         C_M00_AXI_AWUSER_WIDTH           => C_M00_AXI_AWUSER_WIDTH,
         C_M00_AXI_BURST_LEN              => 16,
         C_M00_AXI_BUSER_WIDTH            => C_M00_AXI_BUSER_WIDTH,
         C_M00_AXI_DATA_WIDTH             => 64,
         C_M00_AXI_ID_WIDTH               => 12,
         C_M00_AXI_RUSER_WIDTH            => C_M00_AXI_RUSER_WIDTH,
         -- Parameters of Axi Master Bus Interface M00_AXI
         C_M00_AXI_TARGET_SLAVE_BASE_ADDR => x"40000000",
         C_M00_AXI_WUSER_WIDTH            => C_M00_AXI_WUSER_WIDTH,
         C_S00_AXI_ADDR_WIDTH             => C_S00_AXI_ADDR_WIDTH,
         C_S00_AXI_ARUSER_WIDTH           => C_S00_AXI_ARUSER_WIDTH,
         C_S00_AXI_AWUSER_WIDTH           => C_S00_AXI_AWUSER_WIDTH,
         C_S00_AXI_BUSER_WIDTH            => C_S00_AXI_BUSER_WIDTH,
         C_S00_AXI_DATA_WIDTH             => 32,
         -- Users to add parameters here
         
         -- User parameters ends
         -- Do not modify the parameters beyond this line
         
         
         -- Parameters of Axi Slave Bus Interface S00_AXI
         C_S00_AXI_ID_WIDTH               => C_S00_AXI_ID_WIDTH,
         C_S00_AXI_RUSER_WIDTH            => C_S00_AXI_RUSER_WIDTH,
         C_S00_AXI_WUSER_WIDTH            => C_S00_AXI_WUSER_WIDTH,
         C_SLV_ADDR_WIDTH                 => 16,
         C_SLV_DATA_WIDTH                 => 32
      )
      port map (
         M00_AXI_ACLK        => s00_axi_aclk,
         M00_AXI_ARESETN     => s00_axi_aresetn,
         M00_AXI_ARREADY     => M00_AXI_ARREADY,
         M00_AXI_AWREADY     => M00_AXI_AWREADY,
         M00_AXI_BID         => M00_AXI_BID,
         M00_AXI_BRESP       => M00_AXI_BRESP,
         M00_AXI_BUSER       => M00_AXI_BUSER,
         M00_AXI_BVALID      => M00_AXI_BVALID,
         M00_AXI_RDATA       => M00_AXI_RDATA,
         M00_AXI_RID         => M00_AXI_RID,
         M00_AXI_RLAST       => M00_AXI_RLAST,
         M00_AXI_RRESP       => M00_AXI_RRESP,
         M00_AXI_RUSER       => M00_AXI_RUSER,
         M00_AXI_RVALID      => M00_AXI_RVALID,
         M00_AXI_WREADY      => M00_AXI_WREADY,
         dma_rd              => fifo_rd,
         dma_rd_addr         => lo32,
         dma_rd_mode         => hi4,
         dma_rd_request_size => dma_wr_request_size,
         dma_wdata           => fifo_wdata,
         dma_wr              => fifo_we,
         dma_wr_addr         => lo32,
         dma_wr_mode         => hi4,
         dma_wr_request_size => dma_wr_request_size,
         s00_axi_aclk        => s00_axi_aclk,
         s00_axi_araddr      => s00_axi_araddr,
         s00_axi_arburst     => s00_axi_arburst,
         s00_axi_arcache     => s00_axi_arcache,
         s00_axi_aresetn     => s00_axi_aresetn,
         s00_axi_arid        => s00_axi_arid,
         s00_axi_arlen       => s00_axi_arlen,
         s00_axi_arlock      => s00_axi_arlock,
         s00_axi_arprot      => s00_axi_arprot,
         s00_axi_arqos       => s00_axi_arqos,
         s00_axi_arregion    => s00_axi_arregion,
         s00_axi_arsize      => s00_axi_arsize,
         s00_axi_aruser      => s00_axi_aruser,
         s00_axi_arvalid     => s00_axi_arvalid,
         s00_axi_awaddr      => s00_axi_awaddr,
         s00_axi_awburst     => s00_axi_awburst,
         s00_axi_awcache     => s00_axi_awcache,
         s00_axi_awid        => s00_axi_awid,
         s00_axi_awlen       => s00_axi_awlen,
         s00_axi_awlock      => s00_axi_awlock,
         s00_axi_awprot      => s00_axi_awprot,
         s00_axi_awqos       => s00_axi_awqos,
         s00_axi_awregion    => s00_axi_awregion,
         s00_axi_awsize      => s00_axi_awsize,
         s00_axi_awuser      => s00_axi_awuser,
         s00_axi_awvalid     => s00_axi_awvalid,
         s00_axi_bready      => s00_axi_bready,
         s00_axi_rready      => s00_axi_rready,
         s00_axi_wdata       => s00_axi_wdata,
         s00_axi_wlast       => s00_axi_wlast,
         s00_axi_wstrb       => s00_axi_wstrb,
         s00_axi_wuser       => s00_axi_wuser,
         s00_axi_wvalid      => s00_axi_wvalid,
         sbus_ack            => sbus_ack,
         sbus_rdata          => sbus_rdata,
         sync_i              => sync_i,
         xfer_sync_ext       => lo,
         M00_AXI_ARADDR      => M00_AXI_ARADDR,
         M00_AXI_ARBURST     => M00_AXI_ARBURST,
         M00_AXI_ARCACHE     => M00_AXI_ARCACHE,
         M00_AXI_ARID        => M00_AXI_ARID,
         M00_AXI_ARLEN       => M00_AXI_ARLEN,
         M00_AXI_ARLOCK      => M00_AXI_ARLOCK,
         M00_AXI_ARPROT      => M00_AXI_ARPROT,
         M00_AXI_ARQOS       => M00_AXI_ARQOS,
         M00_AXI_ARSIZE      => M00_AXI_ARSIZE,
         M00_AXI_ARUSER      => M00_AXI_ARUSER,
         M00_AXI_ARVALID     => M00_AXI_ARVALID,
         M00_AXI_AWADDR      => M00_AXI_AWADDR,
         M00_AXI_AWBURST     => M00_AXI_AWBURST,
         M00_AXI_AWCACHE     => M00_AXI_AWCACHE,
         M00_AXI_AWID        => M00_AXI_AWID,
         M00_AXI_AWLEN       => M00_AXI_AWLEN,
         M00_AXI_AWLOCK      => M00_AXI_AWLOCK,
         M00_AXI_AWPROT      => M00_AXI_AWPROT,
         M00_AXI_AWQOS       => M00_AXI_AWQOS,
         M00_AXI_AWSIZE      => M00_AXI_AWSIZE,
         M00_AXI_AWUSER      => M00_AXI_AWUSER,
         M00_AXI_AWVALID     => M00_AXI_AWVALID,
         M00_AXI_BREADY      => M00_AXI_BREADY,
         M00_AXI_RREADY      => M00_AXI_RREADY,
         M00_AXI_WDATA       => M00_AXI_WDATA,
         M00_AXI_WLAST       => M00_AXI_WLAST,
         M00_AXI_WSTRB       => M00_AXI_WSTRB,
         M00_AXI_WUSER       => M00_AXI_WUSER,
         M00_AXI_WVALID      => M00_AXI_WVALID,
         dma_rd_fifosize     => open,
         dma_rdata           => open,
         dma_wr_fifosize     => open,
         irq                 => open,
         s00_axi_arready     => s00_axi_arready,
         s00_axi_awready     => s00_axi_awready,
         s00_axi_bid         => s00_axi_bid,
         s00_axi_bresp       => s00_axi_bresp,
         s00_axi_buser       => s00_axi_buser,
         s00_axi_bvalid      => s00_axi_bvalid,
         s00_axi_rdata       => s00_axi_rdata,
         s00_axi_rid         => s00_axi_rid,
         s00_axi_rlast       => s00_axi_rlast,
         s00_axi_rresp       => s00_axi_rresp,
         s00_axi_ruser       => s00_axi_ruser,
         s00_axi_rvalid      => s00_axi_rvalid,
         s00_axi_wready      => s00_axi_wready,
         sbus_addr           => sbus_addr,
         sbus_be             => open,
         sbus_rd             => sbus_rd,
         sbus_wdata          => sbus_wdata,
         sbus_we             => sbus_we,
         sync_o              => sync_o,
         xfer_done           => open
      );

end struct;
