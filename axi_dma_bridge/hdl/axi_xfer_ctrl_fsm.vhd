-- VHDL Entity axi_dma_bridge.axi_xfer_ctrl.symbol
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 08:24:45 07.11.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
library ieee;
use ieee.std_logic_1164.ALL;
use ieee.std_logic_arith.ALL;
use ieee.std_logic_unsigned.all;
library work;
use work.busdef.all;

entity axi_xfer_ctrl is
   generic( 
      dma_width_g : integer := 128
   );
   port( 
      -- Asserts when transaction is complete
      RXN_DONE                  : in     std_logic;
      -- Asserts when transaction is complete
      TXN_DONE                  : in     std_logic;
      clk                       : in     std_logic;
      fifo_rd_size              : in     std_logic_vector (31 downto 0);
      fifo_wr_size              : in     std_logic_vector (31 downto 0);
      loopback                  : in     std_logic;
      rd_continuous             : in     std_logic;
      rd_snapshot               : in     std_logic;
      reset                     : in     std_logic;
      target_rd_addr_offset     : in     std_logic_vector (31 downto 0);
      target_wr_addr_offset     : in     std_logic_vector (31 downto 0);
      wr_continuous             : in     std_logic;
      wr_snapshot               : in     std_logic;
      xfer_enable               : in     std_logic;
      xfer_init                 : in     std_logic;
      xfer_mode                 : in     std_logic;
      xfer_num_reset            : in     std_logic;
      xfer_rd                   : in     std_logic;
      xfer_rd_base_address      : in     std_logic_vector (31 downto 0);
      xfer_rd_init              : in     std_logic;
      xfer_rd_reset             : in     std_logic;
      xfer_we                   : in     std_logic;
      xfer_wr_base_address      : in     std_logic_vector (31 downto 0);
      xfer_wr_init              : in     std_logic;
      xfer_wr_reset             : in     std_logic;
      -- Users to add ports here
      
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      -- Initiate AXI transactions
      INIT_AXI_RX               : out    std_logic;
      -- Users to add ports here
      
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      -- Initiate AXI transactions
      INIT_AXI_TX               : out    std_logic;
      fifo_rd_ptr               : out    std_logic_vector (31 downto 0);
      fifo_wr_ptr               : out    std_logic_vector (31 downto 0);
      no_of_bursts_req          : out    std_logic_vector (7 downto 0);
      target_slave_base_address : out    std_logic_vector (31 downto 0);
      xfer_done                 : out    std_logic;
      xfer_rd_num_o             : out    std_logic_vector (31 downto 0)
   );

-- Declarations

end axi_xfer_ctrl ;

--
-- VHDL Architecture axi_dma_bridge.axi_xfer_ctrl.fsm
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 08:24:52 07.11.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
library ieee;
use ieee.std_logic_1164.ALL;
use ieee.std_logic_arith.ALL;
use ieee.std_logic_unsigned.all;
library work;
use work.busdef.all;
 
architecture fsm of axi_xfer_ctrl is

   -- Architecture Declarations
   signal xfer_mux: std_logic_vector(4 downto 0);
   signal xfer_wr_num: std_logic_vector(31 downto 0);
   signal xfer_rd_num: std_logic_vector(31 downto 0);
   signal done: std_logic;
   signal wr_addr_offset,rd_addr_offset: std_logic_vector(31 downto 0);
   signal fifo_wr_cnt, fifo_rd_cnt: std_logic_vector(19 downto 0);
   signal wr_snapshot_reset, rd_snapshot_reset: std_logic;
   signal xfer_wr_base_address_reg, xfer_rd_base_address_reg: std_logic_vector(31 downto 0);
   signal xfer_wr_state, xfer_rd_state: std_logic;
   signal trig_interrupt: std_logic;
   signal xfer_rd_reset_flag, xfer_rd_reset_flag_clear: std_logic;

   type state_type is (
      s_write0,
      s_write2,
      s_read0,
      s_read1,
      s_idle,
      s_reset,
      s_done,
      s_write1,
      s_read2
   );
 
   -- Declare current and next state signals
   signal current_state : state_type;
   signal next_state : state_type;

   -- Declare any pre-registered internal signals
   signal target_slave_base_address_cld : std_logic_vector (31 downto 0);
   signal xfer_rd_num_o_cld : std_logic_vector (31 downto 0);

begin

   -----------------------------------------------------------------
   clocked_proc : process ( 
      clk
   )
   -----------------------------------------------------------------
   begin
      if (clk'event and clk = '1') then
         if (reset = '1') then
            current_state <= s_reset;
            -- Default Reset Values
            target_slave_base_address_cld <= (others => '0');
            done <= '0';
            trig_interrupt <= '0';
            xfer_mux <= (others => '0');
            xfer_rd_reset_flag_clear <= '0';
         else
            current_state <= next_state;
            -- Default Assignment To Internals
            done <= '0';
            rd_snapshot_reset <= '0';
            trig_interrupt <= '0';
            wr_snapshot_reset <= '0';
            xfer_rd_reset_flag_clear <= '0';

            -- Interrupts
            if (xfer_enable = '0') then
               null;
            else

               -- Combined Actions
               case current_state is
                  when s_write0 => 
                     xfer_mux <= (others => '0');
                     if xfer_rd_reset_flag = '1' then
                        fifo_rd_cnt <= (others => '0');
                        xfer_rd_reset_flag_clear <= '1';
                     end if;
                     if xfer_wr_reset = '1' then
                        fifo_wr_cnt <= (others => '0');
                     end if;
                     if ((xfer_init = '1' or xfer_wr_init = '1') and xfer_enable='1' and xfer_wr_state = '1' and xfer_we = '1') then 
                        target_slave_base_address_cld <= xfer_wr_base_address_reg+wr_addr_offset;
                        fifo_wr_cnt <= fifo_wr_cnt+1;
                        if fifo_wr_cnt >= fifo_wr_size then
                           fifo_wr_cnt <= (others => '0');
                           xfer_wr_base_address_reg <= xfer_wr_base_address;
                           wr_snapshot_reset <= '1';
                        end if;
                     elsif ((xfer_init = '1' or xfer_rd_init = '1') and xfer_enable='1' and xfer_rd_state = '1' and xfer_rd='1' and xfer_rd_reset = '0') then 
                        target_slave_base_address_cld <= xfer_rd_base_address_reg+rd_addr_offset;
                     end if;
                  when s_write2 => 
                     if (txn_done = '1' and xfer_rd = '1' and xfer_rd_state = '1' and xfer_mode = '0' and xfer_rd_reset = '0') then 
                        target_slave_base_address_cld <= xfer_rd_base_address_reg+rd_addr_offset;--fifo_rd_cnt <= fifo_rd_cnt+1;
                     elsif (txn_done = '1') then 
                        done <= '1';
                     end if;
                  when s_idle => 
                     fifo_wr_cnt <= (others => '0');
                     fifo_rd_cnt <= (others => '0');
                     xfer_rd_base_address_reg <= xfer_rd_base_address;
                     xfer_wr_base_address_reg <= xfer_wr_base_address;
                  when s_done => 
                     trig_interrupt <= '1';
                  when s_read2 => 
                     if (rxn_done = '1') then 
                        done <= '1';
                        fifo_rd_cnt <= fifo_rd_cnt+1;
                        if fifo_rd_cnt >= fifo_rd_size then
                           fifo_rd_cnt <= (others => '0');
                           xfer_wr_base_address_reg <= xfer_rd_base_address;
                           rd_snapshot_reset <= '1';
                        end if;
                     end if;
                  when others =>
                     null;
               end case;
            end if;
         end if;
      end if;
   end process clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : process ( 
      RXN_DONE,
      TXN_DONE,
      current_state,
      xfer_enable,
      xfer_init,
      xfer_mode,
      xfer_rd,
      xfer_rd_init,
      xfer_rd_reset,
      xfer_rd_state,
      xfer_we,
      xfer_wr_init,
      xfer_wr_state
   )
   -----------------------------------------------------------------
   begin

      -- Interrupts
      if (xfer_enable = '0') then
         next_state <= s_idle;
      else
         case current_state is
            when s_write0 => 
               if ((xfer_init = '1' or xfer_wr_init = '1') and xfer_enable='1' and xfer_wr_state = '1' and xfer_we = '1') then 
                  next_state <= s_write1;
               elsif ((xfer_init = '1' or xfer_rd_init = '1') and xfer_enable='1' and xfer_rd_state = '1' and xfer_rd='1' and xfer_rd_reset = '0') then 
                  next_state <= s_read0;
               else
                  next_state <= s_write0;
               end if;
            when s_write2 => 
               if (txn_done = '1' and xfer_rd = '1' and xfer_rd_state = '1' and xfer_mode = '0' and xfer_rd_reset = '0') then 
                  next_state <= s_read0;
               elsif (txn_done = '1') then 
                  next_state <= s_write0;
               else
                  next_state <= s_write2;
               end if;
            when s_read0 => 
               next_state <= s_read1;
            when s_read1 => 
               if (rxn_done = '0') then 
                  next_state <= s_read2;
               else
                  next_state <= s_read1;
               end if;
            when s_idle => 
               next_state <= s_write0;
            when s_reset => 
               next_state <= s_idle;
            when s_done => 
               next_state <= s_write0;
            when s_write1 => 
               if (txn_done = '0') then 
                  next_state <= s_write2;
               else
                  next_state <= s_write1;
               end if;
            when s_read2 => 
               if (rxn_done = '1') then 
                  next_state <= s_done;
               else
                  next_state <= s_read2;
               end if;
            when others =>
               next_state <= s_reset;
         end case;
      end if;
   end process nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : process ( 
      current_state,
      xfer_enable,
      xfer_init,
      xfer_we,
      xfer_wr_init,
      xfer_wr_state
   )
   -----------------------------------------------------------------
   begin
      -- Default Assignment
      INIT_AXI_RX <= '0';
      INIT_AXI_TX <= '0';

      -- Interrupts
      if (xfer_enable = '0') then
         null;
      else

         -- Combined Actions
         case current_state is
            when s_write0 => 
               if xfer_enable = '1' then
                  init_axi_tx <= (xfer_init or xfer_wr_init) and xfer_we and xfer_wr_state;
               end if;
            when s_read0 => 
               init_axi_rx <= '1';
            when others =>
               null;
         end case;
      end if;
   end process output_proc;
 
   -- Concurrent Statements
   -- Clocked output assignments
   target_slave_base_address <= target_slave_base_address_cld;
   xfer_rd_num_o <= xfer_rd_num_o_cld;
   no_of_bursts_req <= X"01";
   xfer_done <= done;
   fifo_wr_ptr <= X"000" & fifo_wr_cnt;
   fifo_rd_ptr <= X"000" & fifo_rd_cnt;
   
   
   g0: if dma_width_g = 64 generate
   wr_addr_offset <= ("00000" & fifo_wr_cnt & "0000000") + target_wr_addr_offset;
   rd_addr_offset <= ("00000" & fifo_rd_cnt & "0000000") +target_rd_addr_offset ;
   end generate g0;
   
   g1: if dma_width_g /= 64 generate
   wr_addr_offset <= ("0000" & fifo_wr_cnt & "00000000") + target_wr_addr_offset;
   rd_addr_offset <= ("0000" & fifo_rd_cnt & "00000000") +target_rd_addr_offset ;
   end generate g1;
   
   process(clk)
   begin
      if rising_edge(clk) then
         if reset = '1'  then
            xfer_rd_reset_flag  <= '0';
        elsif xfer_rd_reset = '1'  then
             xfer_rd_reset_flag  <= '1';
        elsif xfer_rd_reset_flag_clear = '1' then
            xfer_rd_reset_flag  <= '0';
        end if;
      end if;
   end process;
   
   process(clk)
   begin
      if rising_edge(clk) then
         if reset = '1' or wr_snapshot_reset = '1' then
            xfer_wr_state <= '0';
        elsif wr_snapshot = '1' or wr_continuous = '1' then
            xfer_wr_state <= '1';
        end if;
      end if;
   end process;
   
   process(clk)
   begin
      if rising_edge(clk) then
         if reset = '1' or rd_snapshot_reset = '1' then
            xfer_rd_state <= '0';
        elsif rd_snapshot = '1' or rd_continuous = '1' then
            xfer_rd_state <= '1';
        end if;
      end if;
   end process;
end fsm;
