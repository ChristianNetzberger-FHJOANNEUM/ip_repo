-- VHDL Entity proj_gpio_lib.top_gpio.symbol
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 16:37:16 18.12.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

entity top_gpio is
   generic( 
      simulation_g      : boolean          := false;
      C_SLV_ADDR_BASE   : std_logic_vector := X"0000";
      C_SLV_ADDR_RANGE  : std_logic_vector := X"0010";
      C_CORE_CLOCK_FREQ : integer          := 100000000
   );
   port( 
      buttons        : in     std_logic_vector (3 downto 0);
      -- Users to add ports here
      clk            : in     std_logic;
      encoder0       : in     std_logic_vector (1 downto 0);
      encoder1       : in     std_logic_vector (1 downto 0);
      reset          : in     std_logic;
      sbus_ack_mst   : in     std_logic;
      sbus_addr      : in     std_logic_vector (15 downto 0);
      sbus_rd        : in     std_logic;
      sbus_rdata_mst : in     std_logic_vector (31 downto 0);
      sbus_wdata     : in     std_logic_vector (31 downto 0);
      sbus_we        : in     std_logic;
      sliders        : in     std_logic_vector (3 downto 0);
      buzzer         : out    std_logic_vector (1 downto 0);
      irq_o          : out    std_logic;
      leds           : out    std_logic_vector (3 downto 0);
      sbus_ack       : out    std_logic;
      sbus_addr_mst  : out    std_logic_vector (15 downto 0);
      sbus_rd_mst    : out    std_logic;
      sbus_rdata     : out    std_logic_vector (31 downto 0);
      sbus_wdata_mst : out    std_logic_vector (31 downto 0);
      sbus_we_mst    : out    std_logic
   );

-- Declarations

end top_gpio ;

--
-- VHDL Architecture proj_gpio_lib.top_gpio.struct
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 18:43:24 18.12.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
library work;
use work.busdef.all;

library proj_gpio_lib;

architecture struct of top_gpio is

   -- Architecture declarations

   -- Internal signal declarations
   signal button_stb        : std_logic;
   signal buttons_s         : std_logic_vector(3 downto 0);
   signal buttons_stb       : std_logic_vector(3 downto 0);
   signal buzzer_en         : std_logic;
   signal buzzer_toggle_en  : std_logic;
   signal buzzer_toggle_val : std_logic;
   signal encoder0_s        : std_logic_vector(1 downto 0);
   signal encoder0_stb      : std_logic_vector(1 downto 0);
   signal encoder1_s        : std_logic_vector(1 downto 0);
   signal encoder1_stb      : std_logic_vector(1 downto 0);
   signal fcw_o             : std_logic_vector(31 downto 0);
   signal hi                : std_logic;
   signal irq_clear         : std_logic;
   signal irq_flag          : std_logic;
   signal irq_mask          : std_logic;
   signal irq_trig          : std_logic;
   signal lo                : std_logic;
   signal lo10              : std_logic_vector(9 downto 0);
   signal lo4               : std_logic_vector(3 downto 0);
   signal param_val0        : std_logic_vector(3 downto 0);
   signal param_val1        : std_logic_vector(3 downto 0);
   signal reg00             : std_logic_vector(31 downto 0);
   signal reg00_in          : std_logic_vector(31 downto 0);
   signal reg01             : std_logic_vector(31 downto 0);
   signal reg01_in          : std_logic_vector(31 downto 0);
   signal reg02             : std_logic_vector(31 downto 0);
   signal reg02_in          : std_logic_vector(31 downto 0);
   signal reg03             : std_logic_vector(31 downto 0);
   signal reg03_in          : std_logic_vector(31 downto 0);
   signal reg04             : std_logic_vector(31 downto 0);
   signal reg04_in          : std_logic_vector(31 downto 0);
   signal reg05             : std_logic_vector(31 downto 0);
   signal reg05_in          : std_logic_vector(31 downto 0);
   signal reg06             : std_logic_vector(31 downto 0);
   signal reg06_in          : std_logic_vector(31 downto 0);
   signal reg07             : std_logic_vector(31 downto 0);
   signal reg07_in          : std_logic_vector(31 downto 0);
   signal reg08             : std_logic_vector(31 downto 0);
   signal reg08_in          : std_logic_vector(31 downto 0);
   signal reg09             : std_logic_vector(31 downto 0);
   signal reg09_in          : std_logic_vector(31 downto 0);
   signal reg0A             : std_logic_vector(31 downto 0);
   signal reg0A_in          : std_logic_vector(31 downto 0);
   signal reg0B             : std_logic_vector(31 downto 0);
   signal reg0B_in          : std_logic_vector(31 downto 0);
   signal reg0C             : std_logic_vector(31 downto 0);
   signal reg0C_in          : std_logic_vector(31 downto 0);
   signal reg0D             : std_logic_vector(31 downto 0);
   signal reg0D_in          : std_logic_vector(31 downto 0);
   signal reg0E             : std_logic_vector(31 downto 0);
   signal reg0E_in          : std_logic_vector(31 downto 0);
   signal reg0F             : std_logic_vector(31 downto 0);
   signal reg0F_in          : std_logic_vector(31 downto 0);
   signal reg_din           : std_logic_vector( 16*32-1 downto 0 );    -- parallel input for readback
   signal reg_dout          : std_logic_vector( 16*32-1 downto 0 );    -- parallel output of all registers
   signal reg_we            : std_logic_vector( 15 downto 0);          -- active high write strobes
   signal reset_s           : std_logic;
   signal resetval          : std_logic_vector( 16*32-1 downto 0 );
   signal sbus_i            : sbus_i_t;
   signal sbus_o            : sbus_o_t;
   signal sliders_s         : std_logic_vector(3 downto 0);
   signal sliders_stb       : std_logic_vector(3 downto 0);


   -- Component Declarations
   component comp_dds
   generic (
      nbits_g : integer := 32
   );
   port (
      fcw        : in     std_logic_vector (nbits_g-1 downto 0);
      reset      : in     std_logic ;
      enable     : in     std_logic ;
      clk        : in     std_logic ;
      dds_strobe : out    std_logic ;
      dds_wave   : out    std_logic 
   );
   end component;
   component comp_param_reg
   generic (
      nbits_g       : integer := 4;
      limit_hi_g    : integer := 15;
      limit_lo_g    : integer := 0;
      reset_val_g   : integer := 7;
      use_din_g     : boolean := false;
      use_encoder_g : boolean := true
   );
   port (
      clk         : in     std_logic ;
      reset       : in     std_logic ;
      encoder     : in     std_logic_vector (1 downto 0);
      encoder_stb : in     std_logic_vector (1 downto 0);
      inc         : in     std_logic ;
      dec         : in     std_logic ;
      din         : in     std_logic_vector (nbits_g-1 downto 0);
      we          : in     std_logic ;
      en_o        : out    std_logic ;
      max_val     : out    std_logic ;
      min_val     : out    std_logic ;
      param_val   : out    std_logic_vector (nbits_g-1 downto 0)
   );
   end component;
   component comp_signal_synchr
   generic (
      simulation_g : boolean := false
   );
   port (
      buttons      : in     std_logic_vector (3 downto 0);
      sliders      : in     std_logic_vector (3 downto 0);
      encoder0     : in     std_logic_vector (1 downto 0);
      encoder1     : in     std_logic_vector (1 downto 0);
      buttons_s    : out    std_logic_vector (3 downto 0);
      sliders_s    : out    std_logic_vector (3 downto 0);
      encoder0_s   : out    std_logic_vector (1 downto 0);
      encoder1_s   : out    std_logic_vector (1 downto 0);
      buttons_stb  : out    std_logic_vector (3 downto 0);
      sliders_stb  : out    std_logic_vector (3 downto 0);
      encoder0_stb : out    std_logic_vector (1 downto 0);
      encoder1_stb : out    std_logic_vector (1 downto 0);
      clk          : in     std_logic 
   );
   end component;
   component comp_tonefrequency_lut
   port (
      index : in     std_logic_vector (3 downto 0);
      fcw_o : out    std_logic_vector (31 downto 0)
   );
   end component;
   component register_array_resetval
   generic (
      addr_width_g : integer := 8;      --width of address
      data_width_g : integer := 8;      --width of data
      addr_base_g  : std_logic_vector;
      addr_range_g : std_logic_vector;
      nregs_g      : integer := 16      --number of registers
   );
   port (
      sbus_o   : out    sbus_o_t ;
      sbus_i   : in     sbus_i_t ;
      resetval : in     std_logic_vector ( nregs_g*data_width_g-1 downto 0 );
      reg_din  : in     std_logic_vector ( nregs_g*data_width_g-1 downto 0 ); -- parallel input for readback
      reg_dout : out    std_logic_vector ( nregs_g*data_width_g-1 downto 0 ); -- parallel output of all registers
      we       : out    std_logic_vector ( nregs_g-1 downto 0);               -- active high write strobes
      reset    : in     std_logic ;                                           -- synchronous, active high reset
      clk      : in     std_logic                                             -- register clock
   );
   end component;

   -- Optional embedded configurations
   -- pragma synthesis_off
   for all : comp_dds use entity proj_gpio_lib.comp_dds;
   for all : comp_param_reg use entity proj_gpio_lib.comp_param_reg;
   for all : comp_signal_synchr use entity proj_gpio_lib.comp_signal_synchr;
   for all : comp_tonefrequency_lut use entity proj_gpio_lib.comp_tonefrequency_lut;
   for all : register_array_resetval use entity proj_gpio_lib.register_array_resetval;
   -- pragma synthesis_on


begin
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 1 interrupt_source
   -- connect the interrupt source
   irq_trig <= buttons_stb(0);  
   
   -- bit0 of reg02 is the interrupt enable mask bit
   irq_mask <= reg02(0);
   
   --clear the interrupt by wirting a '1' to bit1
   -- of the interrupt control register reg02
   irq_clear <= reg02(1) and reg_we(2);                      

   -- HDL Embedded Text Block 4 eb4
   process(clk)
   begin
      if rising_edge(clk) then
         if reset_s = '1' then
             buzzer_toggle_val <= '0';
        elsif  buzzer_toggle_en = '1' then
             buzzer_toggle_val <= not buzzer_toggle_val;
         end if;
      end if;
   end process; 
   
   
   process(clk)
   begin
      if rising_edge(clk) then
           buzzer(0) <= buzzer_toggle_val and buzzer_en;
           buzzer(1) <= not (buzzer_toggle_val and buzzer_en);
      end if;
   end process;
   leds <= reg03(3 downto 0);
   buzzer_en <= reg04(0);
   

   -- HDL Embedded Text Block 5 reg_slice3
   --slice registers from vector---------------
   reg00 <= reg_dout( 0*32+31 downto 0*32);
   reg01 <= reg_dout( 1*32+31 downto 1*32);
   reg02 <= reg_dout( 2*32+31 downto 2*32);
   reg03 <= reg_dout( 3*32+31 downto 3*32);
   reg04 <= reg_dout( 4*32+31 downto 4*32);
   reg05 <= reg_dout( 5*32+31 downto 5*32);
   reg06 <= reg_dout( 6*32+31 downto 6*32);
   reg07 <= reg_dout( 7*32+31 downto 7*32);
   reg08 <= reg_dout( 8*32+31 downto 8*32);
   reg09 <= reg_dout( 9*32+31 downto 9*32);
   reg0A <= reg_dout( 10*32+31 downto 10*32);
   reg0B <= reg_dout( 11*32+31 downto 11*32);
   reg0C <= reg_dout( 12*32+31 downto 12*32);
   reg0D <= reg_dout( 13*32+31 downto 13*32);
   reg0E <= reg_dout( 14*32+31 downto 14*32);
   reg0F <= reg_dout( 15*32+31 downto 15*32);
   
   ---readback register values----
   process(clk)
   begin
      if rising_edge(clk) then
            -- default assignment: internal register readback----------
            reg_din <= reg_dout; 
           --external readback registers-----
          --uncomment line if external readback wanted
   --         reg_din(0*32+31 downto 0*32) <= reg00_in;
   --         reg_din(1*32+31 downto 1*32) <= reg01_in;
              reg_din(2*32+31 downto 2*32) <= reg02_in;
              reg_din(6*32+31 downto 6*32) <= reg06_in;
              reg_din(7*32+31 downto 7*32) <= reg07_in;
              reg_din(8*32+31 downto 8*32) <= reg08_in;
    --        reg_din(9*32+31 downto 9*32) <= reg09_in;
   --         reg_din(10*32+31 downto 10*32) <= reg0A_in;
   --         reg_din(11*32+31 downto 11*32) <= reg0B_in;
   --         reg_din(12*32+31 downto 12*32) <= reg0C_in;
   --         reg_din(13*32+31 downto 13*32) <= reg0D_in;
   --         reg_din(14*32+31 downto 14*32) <= reg0E_in;
   --         reg_din(15*32+31 downto 15*32) <= reg0F_in;
      end if;
   end process;
                                    

   -- HDL Embedded Text Block 6 eb5
   --optionally slice single signals-----
               

   -- HDL Embedded Text Block 7 const_values2
   hi <= '1';
   lo <= '0';  
   lo10 <= (others => '0');     
   lo4 <= (others => '0');                                    

   -- HDL Embedded Text Block 8 interrupt_logic1
   ---this interrupt flag must be cleared by SW (interrupt handler)
   process(clk)
   begin
      if rising_edge(clk) then
          if reset = '1' or irq_clear='1'  then
             irq_flag<= '0';
          elsif  irq_trig = '1' then
             irq_flag <= '1';
          end if;
      end if;
   end process;   
   
   ---apply the interrupt mask-----
   irq_o <= irq_flag and irq_mask;                  

   -- HDL Embedded Text Block 9 slave_bus_attachment1
   ----create record-types for sbus--------------------
   sbus_i.addr <= sbus_addr;
   sbus_i.wdata <= sbus_wdata;
   sbus_i.we <= sbus_we;
   sbus_i.rd <= sbus_rd;
   ---multiplexing two sbus branches-----
   sbus_ack <= sbus_o.ack or sbus_ack_mst;
   sbus_rdata <= sbus_o.rdata or sbus_rdata_mst;
   
   sbus_addr_mst <= sbus_addr;
   sbus_wdata_mst <= sbus_wdata;
   sbus_we_mst <= sbus_we;
   sbus_rd_mst <= sbus_rd;
   

   -- HDL Embedded Text Block 10 register_resetvalues1
   --default reset values for registerblock
   process(resetval)
   begin
      resetval <= (others => '0');
      resetval(1*32+31 downto 1*32) <= X"00005000"; --example res val for reg01
      resetval(2*32+31 downto 2*32) <= conv_std_logic_vector(1000000,32); --example res val for reg02
      resetval(3*32+31 downto 3*32) <= conv_std_logic_vector(100000,32); --example res val for reg02
   end process;                                

   -- HDL Embedded Text Block 11 readable_regs1
   ----concat readable registers-----
   reg02_in <= reg02(31 downto 2)  & irq_flag  & reg02(0);
   reg06_in <= X"000000" & buttons_s & sliders_s;
   reg07_in(31 downto param_val0'length) <= (others => '0');
   reg07_in(param_val0'range) <= param_val0;
   reg08_in(31 downto param_val1'length) <= (others => '0');
   reg08_in(param_val1'range) <= param_val1;
   
                       


   -- Instance port mappings.
   U_5 : comp_dds
      generic map (
         nbits_g => 32
      )
      port map (
         fcw        => fcw_o,
         reset      => reset_s,
         enable     => hi,
         clk        => clk,
         dds_strobe => buzzer_toggle_en,
         dds_wave   => open
      );
   U_2 : comp_param_reg
      generic map (
         nbits_g       => 4,
         limit_hi_g    => 14,
         limit_lo_g    => 0,
         reset_val_g   => 6,
         use_din_g     => false,
         use_encoder_g => true
      )
      port map (
         clk         => clk,
         reset       => reset,
         encoder     => encoder0_s,
         encoder_stb => encoder0_stb,
         inc         => buttons_stb(2),
         dec         => buttons_stb(1),
         din         => sliders_s,
         we          => buttons_stb(3),
         en_o        => open,
         max_val     => open,
         min_val     => open,
         param_val   => param_val0
      );
   U_3 : comp_param_reg
      generic map (
         nbits_g       => 4,
         limit_hi_g    => 14,
         limit_lo_g    => 0,
         reset_val_g   => 6,
         use_din_g     => false,
         use_encoder_g => true
      )
      port map (
         clk         => clk,
         reset       => reset,
         encoder     => encoder1_s,
         encoder_stb => encoder1_stb,
         inc         => lo,
         dec         => lo,
         din         => lo4,
         we          => lo,
         en_o        => open,
         max_val     => open,
         min_val     => open,
         param_val   => param_val1
      );
   U_1 : comp_signal_synchr
      generic map (
         simulation_g => simulation_g
      )
      port map (
         buttons      => buttons,
         sliders      => sliders,
         encoder0     => encoder0,
         encoder1     => encoder1,
         buttons_s    => buttons_s,
         sliders_s    => sliders_s,
         encoder0_s   => encoder0_s,
         encoder1_s   => encoder1_s,
         buttons_stb  => buttons_stb,
         sliders_stb  => sliders_stb,
         encoder0_stb => encoder0_stb,
         encoder1_stb => encoder1_stb,
         clk          => clk
      );
   U_4 : comp_tonefrequency_lut
      port map (
         index => reg05(3 downto 0),
         fcw_o => fcw_o
      );
   U_0 : register_array_resetval
      generic map (
         addr_width_g => 16,             --width of address
         data_width_g => 32,             --width of data
         addr_base_g  => C_SLV_ADDR_BASE,
         addr_range_g => C_SLV_ADDR_RANGE,
         nregs_g      => 16              --number of registers
      )
      port map (
         sbus_o   => sbus_o,
         sbus_i   => sbus_i,
         resetval => resetval,
         reg_din  => reg_din,
         reg_dout => reg_dout,
         we       => reg_we,
         reset    => reset,
         clk      => clk
      );

end struct;
